<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>午夜飞行</title>
  
  <subtitle>个人学习生活记录网站</subtitle>
  <link href="https://striver98.github.io/atom.xml" rel="self"/>
  
  <link href="https://striver98.github.io/"/>
  <updated>2025-04-20T06:38:40.928Z</updated>
  <id>https://striver98.github.io/</id>
  
  <author>
    <name>Wang Zhixuan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="https://striver98.github.io/2025/04/20/hello-world/"/>
    <id>https://striver98.github.io/2025/04/20/hello-world/</id>
    <published>2025-04-20T06:35:51.214Z</published>
    <updated>2025-04-20T06:38:40.928Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://striver98.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="node.js" scheme="https://striver98.github.io/tags/node-js/"/>
    
    <category term="hexo" scheme="https://striver98.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>自动化本科毕业设计记录</title>
    <link href="https://striver98.github.io/2025/02/17/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9C%AC%E7%A7%91%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E8%AE%B0%E5%BD%95/"/>
    <id>https://striver98.github.io/2025/02/17/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9C%AC%E7%A7%91%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E8%AE%B0%E5%BD%95/</id>
    <published>2025-02-17T03:18:20.000Z</published>
    <updated>2025-02-17T03:18:20.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>课题题目：基于Sigmoid函数的变步长LMS自适应滤波算法改进</p><p>课题内容及要求：变步长 LMS 自适应滤波算法因其计算简单 、易于实现等特点在众多领域得到了广泛应用 。 在变步长 LMS 自适应滤波算法中，步长调整模型是影响算法性能的关键因素 。课题通过深入分析步长调整原则及存在问题，研究构建基于 Sigmoid 函数的步长调整模型，并以此为基础设计变步长 LMS 算法，通过实验验证其有效性。</p><p>课题时间： 2024 年 12 月 至 2025 年 5 月<br>具体安排：<br>2024-2025 （1）学期安排：查阅文献资料，了解课题相关技术研究现状等，完成开题报告并上传。<br>2024 2025 （2）学期安排：<br>（1）1-4 周 进一步查阅资料，深入学习变步长 LMS 自适应滤波算法的有关知识，初步实现常规算法的仿真实验。<br>（2）5-7 周 分析变步长 LMS 自适应滤波算法中步长调整原则，针对常规算法中步长调整模型所存在的问题，重点研究基于 Sigmoid 函数的步长调整模型，并设计相应的变步长 LMS 算法， 进行实验分析验证其性能。撰写论文初稿。<br>（3）8-11 周 进一步完善，完成论文定稿，完成送检查重、评阅，制作 PPT ，并准备答辩。<br>（4）12-13 周 论文修改完善，完成终稿并提交。</p></blockquote><h1 id="常规算法的仿真"><a href="#常规算法的仿真" class="headerlink" title="常规算法的仿真"></a>常规算法的仿真</h1><p>滤波：$y(n)&#x3D;w^{T}(n)x(n)$</p><p>输出误差：$e(n)&#x3D;d(n)-y(n)$</p><p>额外误差（EMSE）：$\xi (n)&#x3D;e(n)-t(n)$（$t(n)$为外部噪声信号）</p><p>权系数更新：$w(n+1)&#x3D;w(n)+\mu (n)e(n)x(n)$</p><p>步长调正函数：$\mu (n)&#x3D;\beta (\frac{1}{1+e^{-\alpha \left | e(x) \right | } } -0.5)$</p><p>变步长LMS算法的思想：在算法收敛阶段采用大的迭代步长以获得较快的收敛速度，待算法达到稳态后以较小的迭代步长来减小稳态误差。</p><h2 id="SVSLMS算法仿真"><a href="#SVSLMS算法仿真" class="headerlink" title="SVSLMS算法仿真"></a>SVSLMS算法仿真</h2><p>$\mu (n)&#x3D;\beta (\frac{1}{1+e^{-\alpha \left | e(x) \right | } } -0.5)$</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% [25]覃景繁,欧阳景正. 一种新的变步长LMS自适应滤波算法[J]. 数据采集与处理,1997,12(3):171-174.</span></span><br><span class="line">clear; clc; close all;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 参数设置</span></span><br><span class="line">L = <span class="number">2</span>;                  <span class="comment">% 滤波器阶数</span></span><br><span class="line"><span class="built_in">true</span>_coef1 = [<span class="number">0.8</span>; <span class="number">0.5</span>];<span class="comment">% 初始真实系数</span></span><br><span class="line"><span class="built_in">true</span>_coef2 = [<span class="number">0.4</span>; <span class="number">0.2</span>];<span class="comment">% 500点后系数</span></span><br><span class="line">N = <span class="number">1000</span>;               <span class="comment">% 采样点数</span></span><br><span class="line">trials = <span class="number">200</span>;           <span class="comment">% 独立实验次数</span></span><br><span class="line">alpha = <span class="number">0.5</span>;            <span class="comment">% Sigmoid参数</span></span><br><span class="line"><span class="built_in">beta</span> = <span class="number">0.8</span>;             <span class="comment">% 步长缩放因子</span></span><br><span class="line">noise_var = <span class="number">0.04</span>;       <span class="comment">% 噪声方差</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 预分配存储空间</span></span><br><span class="line">mu_avg = <span class="built_in">zeros</span>(N,<span class="number">1</span>);    <span class="comment">% 平均步长</span></span><br><span class="line">e_avg = <span class="built_in">zeros</span>(N,<span class="number">1</span>);     <span class="comment">% 平均误差</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 主循环（200次独立实验）</span></span><br><span class="line"><span class="keyword">for</span> trial = <span class="number">1</span>:trials</span><br><span class="line">    <span class="comment">% 生成信号</span></span><br><span class="line">    x = <span class="built_in">randn</span>(N,<span class="number">1</span>);     <span class="comment">% 方差1的高斯白噪声</span></span><br><span class="line">    v = <span class="built_in">sqrt</span>(noise_var)*<span class="built_in">randn</span>(N,<span class="number">1</span>); <span class="comment">% 干扰噪声</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 初始化变量</span></span><br><span class="line">    w = <span class="built_in">zeros</span>(L,<span class="number">1</span>);     <span class="comment">% 滤波器系数</span></span><br><span class="line">    d = <span class="built_in">zeros</span>(N,<span class="number">1</span>);     <span class="comment">% 期望信号</span></span><br><span class="line">    e = <span class="built_in">zeros</span>(N,<span class="number">1</span>);     <span class="comment">% 误差信号</span></span><br><span class="line">    mu_history = <span class="built_in">zeros</span>(N,<span class="number">1</span>); <span class="comment">% 步长记录</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">% 生成时变系统输出</span></span><br><span class="line">    <span class="keyword">for</span> n = L:N</span><br><span class="line">        <span class="comment">% 系统切换检测</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">500</span></span><br><span class="line">            <span class="built_in">true</span>_coef = <span class="built_in">true</span>_coef1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">true</span>_coef = <span class="built_in">true</span>_coef2;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">% 生成期望信号</span></span><br><span class="line">        x_vec = x(n:<span class="number">-1</span>:n-L+<span class="number">1</span>);</span><br><span class="line">        d(n) = <span class="built_in">true</span>_coef&#x27; * x_vec + v(n);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% LMS算法执行</span></span><br><span class="line">    <span class="keyword">for</span> n = L:N<span class="number">-1</span></span><br><span class="line">        <span class="comment">% 当前输入向量</span></span><br><span class="line">        x_vec = x(n:<span class="number">-1</span>:n-L+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">% 滤波器输出</span></span><br><span class="line">        y = w&#x27; * x_vec;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">% 误差计算</span></span><br><span class="line">        e(n) = d(n) - y;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">% Sigmoid变步长计算</span></span><br><span class="line">        mu = <span class="built_in">beta</span> * (<span class="number">1</span>/(<span class="number">1</span> + <span class="built_in">exp</span>(-alpha*<span class="built_in">abs</span>(e(n)))) - <span class="number">0.5</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">% 系数更新</span></span><br><span class="line">        w = w + mu * e(n) * x_vec;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">% 记录步长</span></span><br><span class="line">        mu_history(n) = mu;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 累积数据</span></span><br><span class="line">    mu_avg = mu_avg + mu_history;</span><br><span class="line">    e_avg = e_avg + <span class="built_in">abs</span>(e);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 数据后处理</span></span><br><span class="line">mu_avg = mu_avg / trials;</span><br><span class="line">e_avg = e_avg / trials;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 结果可视化</span></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(mu_avg, <span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1.5</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;迭代次数&#x27;</span>); ylabel(<span class="string">&#x27;步长均值&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;步长变化曲线&#x27;</span>);</span><br><span class="line">grid on;</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">semilogy(e_avg, <span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1.5</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;迭代次数&#x27;</span>); ylabel(<span class="string">&#x27;|误差|均值&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;误差收敛曲线&#x27;</span>);</span><br><span class="line">grid on;</span><br></pre></td></tr></table></figure><h2 id="G-SVSLMS算法仿真"><a href="#G-SVSLMS算法仿真" class="headerlink" title="G-SVSLMS算法仿真"></a>G-SVSLMS算法仿真</h2><p>$\mu (n)&#x3D;\beta (n)(1-exp(\alpha (n)\left | e(n) \right |^2) $</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%%[26]高鹰,谢胜利. 一种变步长LMS自适应滤波算法及分析[J]. 电子学报,2001,29(8):1094-1097.</span></span><br><span class="line">clear; clc; close all;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 参数设置</span></span><br><span class="line">L = <span class="number">2</span>;                  <span class="comment">% 滤波器阶数</span></span><br><span class="line"><span class="built_in">true</span>_coef1 = [<span class="number">0.8</span>; <span class="number">0.5</span>];<span class="comment">% 初始真实系数</span></span><br><span class="line"><span class="built_in">true</span>_coef2 = [<span class="number">0.4</span>; <span class="number">0.2</span>];<span class="comment">% 500点后系数</span></span><br><span class="line">N = <span class="number">1000</span>;               <span class="comment">% 采样点数</span></span><br><span class="line">trials = <span class="number">200</span>;           <span class="comment">% 独立实验次数</span></span><br><span class="line">alpha = <span class="number">300</span>;            <span class="comment">% Sigmoid参数</span></span><br><span class="line"><span class="built_in">beta</span> = <span class="number">0.2</span>;             <span class="comment">% 步长缩放因子</span></span><br><span class="line">noise_var = <span class="number">0.04</span>;       <span class="comment">% 噪声方差</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 预分配存储空间</span></span><br><span class="line">mu_avg = <span class="built_in">zeros</span>(N,<span class="number">1</span>);    <span class="comment">% 平均步长</span></span><br><span class="line">e_avg = <span class="built_in">zeros</span>(N,<span class="number">1</span>);     <span class="comment">% 平均误差</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 主循环（200次独立实验）</span></span><br><span class="line"><span class="keyword">for</span> trial = <span class="number">1</span>:trials</span><br><span class="line">    <span class="comment">% 生成信号</span></span><br><span class="line">    x = <span class="built_in">randn</span>(N,<span class="number">1</span>);     <span class="comment">% 方差1的高斯白噪声</span></span><br><span class="line">    v = <span class="built_in">sqrt</span>(noise_var)*<span class="built_in">randn</span>(N,<span class="number">1</span>); <span class="comment">% 干扰噪声</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 初始化变量</span></span><br><span class="line">    w = <span class="built_in">zeros</span>(L,<span class="number">1</span>);     <span class="comment">% 滤波器系数</span></span><br><span class="line">    d = <span class="built_in">zeros</span>(N,<span class="number">1</span>);     <span class="comment">% 期望信号</span></span><br><span class="line">    e = <span class="built_in">zeros</span>(N,<span class="number">1</span>);     <span class="comment">% 误差信号</span></span><br><span class="line">    mu_history = <span class="built_in">zeros</span>(N,<span class="number">1</span>); <span class="comment">% 步长记录</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">% 生成时变系统输出</span></span><br><span class="line">    <span class="keyword">for</span> n = L:N</span><br><span class="line">        <span class="comment">% 系统切换检测</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">500</span></span><br><span class="line">            <span class="built_in">true</span>_coef = <span class="built_in">true</span>_coef1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">true</span>_coef = <span class="built_in">true</span>_coef2;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">% 生成期望信号</span></span><br><span class="line">        x_vec = x(n:<span class="number">-1</span>:n-L+<span class="number">1</span>);</span><br><span class="line">        d(n) = <span class="built_in">true</span>_coef&#x27; * x_vec + v(n);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% LMS算法执行</span></span><br><span class="line">    <span class="keyword">for</span> n = L:N<span class="number">-1</span></span><br><span class="line">        <span class="comment">% 当前输入向量</span></span><br><span class="line">        x_vec = x(n:<span class="number">-1</span>:n-L+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">% 滤波器输出</span></span><br><span class="line">        y = w&#x27; * x_vec;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">% 误差计算</span></span><br><span class="line">        e(n) = d(n) - y;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">% 变步长计算</span></span><br><span class="line">        mu = <span class="built_in">beta</span> * (<span class="number">1</span>-<span class="built_in">exp</span>(-alpha*(<span class="built_in">abs</span>(e(n)))^<span class="number">2</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">% 系数更新</span></span><br><span class="line">        w = w + mu * e(n) * x_vec;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">% 记录步长</span></span><br><span class="line">        mu_history(n) = mu;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 累积数据</span></span><br><span class="line">    mu_avg = mu_avg + mu_history;</span><br><span class="line">    e_avg = e_avg + <span class="built_in">abs</span>(e);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 数据后处理</span></span><br><span class="line">mu_avg = mu_avg / trials;</span><br><span class="line">e_avg = e_avg / trials;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 结果可视化</span></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(mu_avg, <span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1.5</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;迭代次数&#x27;</span>); ylabel(<span class="string">&#x27;步长均值&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;步长变化曲线&#x27;</span>);</span><br><span class="line">grid on;</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">semilogy(e_avg, <span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1.5</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;迭代次数&#x27;</span>); ylabel(<span class="string">&#x27;|误差|均值&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;误差收敛曲线&#x27;</span>);</span><br><span class="line">grid on;</span><br></pre></td></tr></table></figure><h2 id="G-SVSLMS算法改进仿真"><a href="#G-SVSLMS算法改进仿真" class="headerlink" title="G-SVSLMS算法改进仿真"></a>G-SVSLMS算法改进仿真</h2><p>$\alpha (n)&#x3D;\eta \left | e(n)e(n-1) \right | ^{m}$</p><p>$\beta (n)&#x3D;p\beta (n-1)+qe^2(n)$</p><p>$\mu (n)&#x3D;\beta (n)(1-exp(\alpha (n)\left | e(n) \right |^2) $</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%%[27]胡异丁,王凤森,杨敏,等. 一种改进变步长LMS自适应滤波算法[J]. 计算机仿真,2020,37(7):291-295.</span></span><br><span class="line">clear; clc; close all;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 参数设置</span></span><br><span class="line">L = <span class="number">2</span>;                  <span class="comment">% 滤波器阶数</span></span><br><span class="line"><span class="built_in">true</span>_coef1 = [<span class="number">0.8</span>; <span class="number">0.5</span>];<span class="comment">% 初始真实系数</span></span><br><span class="line"><span class="built_in">true</span>_coef2 = [<span class="number">0.4</span>; <span class="number">0.2</span>];<span class="comment">% 500点后系数</span></span><br><span class="line">N = <span class="number">1000</span>;               <span class="comment">% 采样点数</span></span><br><span class="line">trials = <span class="number">200</span>;           <span class="comment">% 独立实验次数</span></span><br><span class="line">eta = <span class="number">100</span>;              <span class="comment">% 参数η</span></span><br><span class="line">m = <span class="number">0.5</span>;                <span class="comment">% 参数m</span></span><br><span class="line">p = <span class="number">0.95</span>;               <span class="comment">% 参数p</span></span><br><span class="line">q = <span class="number">0.02</span>;               <span class="comment">% 参数q</span></span><br><span class="line">noise_var = <span class="number">0.04</span>;       <span class="comment">% 噪声方差</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 预分配存储空间</span></span><br><span class="line">mu_avg = <span class="built_in">zeros</span>(N,<span class="number">1</span>);    <span class="comment">% 平均步长</span></span><br><span class="line">e_avg = <span class="built_in">zeros</span>(N,<span class="number">1</span>);     <span class="comment">% 平均误差</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 主循环（200次独立实验）</span></span><br><span class="line"><span class="keyword">for</span> trial = <span class="number">1</span>:trials</span><br><span class="line">    <span class="comment">% 生成信号</span></span><br><span class="line">    x = <span class="built_in">randn</span>(N,<span class="number">1</span>);     <span class="comment">% 方差1的高斯白噪声</span></span><br><span class="line">    v = <span class="built_in">sqrt</span>(noise_var)*<span class="built_in">randn</span>(N,<span class="number">1</span>); <span class="comment">% 干扰噪声</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 初始化变量</span></span><br><span class="line">    w = <span class="built_in">zeros</span>(L,<span class="number">1</span>);     <span class="comment">% 滤波器系数</span></span><br><span class="line">    d = <span class="built_in">zeros</span>(N,<span class="number">1</span>);     <span class="comment">% 期望信号</span></span><br><span class="line">    e = <span class="built_in">zeros</span>(N,<span class="number">1</span>);     <span class="comment">% 误差信号</span></span><br><span class="line">    mu_history = <span class="built_in">zeros</span>(N,<span class="number">1</span>); <span class="comment">% 步长记录</span></span><br><span class="line">    <span class="built_in">beta</span> = <span class="built_in">zeros</span>(N,<span class="number">1</span>);  <span class="comment">% 动态步长因子</span></span><br><span class="line">    alpha = <span class="built_in">zeros</span>(N,<span class="number">1</span>); <span class="comment">% 动态α因子</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">% 生成时变系统输出</span></span><br><span class="line">    <span class="keyword">for</span> n = L:N</span><br><span class="line">        <span class="comment">% 系统切换检测</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">500</span></span><br><span class="line">            <span class="built_in">true</span>_coef = <span class="built_in">true</span>_coef1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">true</span>_coef = <span class="built_in">true</span>_coef2;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">% 生成期望信号</span></span><br><span class="line">        x_vec = x(n:<span class="number">-1</span>:n-L+<span class="number">1</span>);</span><br><span class="line">        d(n) = <span class="built_in">true</span>_coef&#x27; * x_vec + v(n);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% LMS算法执行</span></span><br><span class="line">    <span class="keyword">for</span> n = L:N<span class="number">-1</span></span><br><span class="line">        <span class="comment">% 当前输入向量</span></span><br><span class="line">        x_vec = x(n:<span class="number">-1</span>:n-L+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">% 滤波器输出</span></span><br><span class="line">        y = w&#x27; * x_vec;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">% 误差计算</span></span><br><span class="line">        e(n) = d(n) - y;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">% 动态α因子计算</span></span><br><span class="line">        <span class="keyword">if</span> n &gt; <span class="number">1</span></span><br><span class="line">            alpha(n) = eta * <span class="built_in">abs</span>(e(n) * e(n<span class="number">-1</span>))^m;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            alpha(n) = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">% 动态步长因子计算</span></span><br><span class="line">        <span class="keyword">if</span> n &gt; <span class="number">1</span></span><br><span class="line">            <span class="built_in">beta</span>(n) = p * <span class="built_in">beta</span>(n<span class="number">-1</span>) + q * e(n)^<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">beta</span>(n) = q * e(n)^<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">% 变步长计算</span></span><br><span class="line">        mu = <span class="built_in">beta</span>(n) * (<span class="number">1</span> - <span class="built_in">exp</span>(-alpha(n) * <span class="built_in">abs</span>(e(n))^<span class="number">2</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">% 系数更新</span></span><br><span class="line">        w = w + mu * e(n) * x_vec;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">% 记录步长</span></span><br><span class="line">        mu_history(n) = mu;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 累积数据</span></span><br><span class="line">    mu_avg = mu_avg + mu_history;</span><br><span class="line">    e_avg = e_avg + <span class="built_in">abs</span>(e);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 数据后处理</span></span><br><span class="line">mu_avg = mu_avg / trials;</span><br><span class="line">e_avg = e_avg / trials;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 结果可视化</span></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(mu_avg, <span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1.5</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;迭代次数&#x27;</span>); ylabel(<span class="string">&#x27;步长均值&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;步长变化曲线&#x27;</span>);</span><br><span class="line">grid on;</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">semilogy(e_avg, <span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1.5</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;迭代次数&#x27;</span>); ylabel(<span class="string">&#x27;|误差|均值&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;误差收敛曲线&#x27;</span>);</span><br><span class="line">grid on;</span><br></pre></td></tr></table></figure><h2 id="SVSLMS算法改进仿真1"><a href="#SVSLMS算法改进仿真1" class="headerlink" title="SVSLMS算法改进仿真1"></a>SVSLMS算法改进仿真1</h2><p>$\mu (n)&#x3D;\beta (\frac{1}{1+exp(-\alpha (|e(n)|^3)}-0.5)$</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%%[28]罗小东,贾振红,王强. 一种新的变步长LMS自适应滤波算法[J]. 电子学报,2006,34(6):1123-1126.</span></span><br><span class="line">clear; clc; close all;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 参数设置</span></span><br><span class="line">L = <span class="number">2</span>;                  <span class="comment">% 滤波器阶数</span></span><br><span class="line"><span class="built_in">true</span>_coef1 = [<span class="number">0.8</span>; <span class="number">0.5</span>];<span class="comment">% 初始真实系数</span></span><br><span class="line"><span class="built_in">true</span>_coef2 = [<span class="number">0.4</span>; <span class="number">0.2</span>];<span class="comment">% 500点后系数</span></span><br><span class="line">N = <span class="number">1000</span>;               <span class="comment">% 采样点数</span></span><br><span class="line">trials = <span class="number">200</span>;           <span class="comment">% 独立实验次数</span></span><br><span class="line">alpha = <span class="number">3000</span>;            <span class="comment">% Sigmoid参数</span></span><br><span class="line"><span class="built_in">beta</span> = <span class="number">0.2</span>;             <span class="comment">% 步长缩放因子</span></span><br><span class="line">noise_var = <span class="number">0.04</span>;       <span class="comment">% 噪声方差</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 预分配存储空间</span></span><br><span class="line">mu_avg = <span class="built_in">zeros</span>(N,<span class="number">1</span>);    <span class="comment">% 平均步长</span></span><br><span class="line">e_avg = <span class="built_in">zeros</span>(N,<span class="number">1</span>);     <span class="comment">% 平均误差</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 主循环（200次独立实验）</span></span><br><span class="line"><span class="keyword">for</span> trial = <span class="number">1</span>:trials</span><br><span class="line">    <span class="comment">% 生成信号</span></span><br><span class="line">    x = <span class="built_in">randn</span>(N,<span class="number">1</span>);     <span class="comment">% 方差1的高斯白噪声</span></span><br><span class="line">    v = <span class="built_in">sqrt</span>(noise_var)*<span class="built_in">randn</span>(N,<span class="number">1</span>); <span class="comment">% 干扰噪声</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 初始化变量</span></span><br><span class="line">    w = <span class="built_in">zeros</span>(L,<span class="number">1</span>);     <span class="comment">% 滤波器系数</span></span><br><span class="line">    d = <span class="built_in">zeros</span>(N,<span class="number">1</span>);     <span class="comment">% 期望信号</span></span><br><span class="line">    e = <span class="built_in">zeros</span>(N,<span class="number">1</span>);     <span class="comment">% 误差信号</span></span><br><span class="line">    mu_history = <span class="built_in">zeros</span>(N,<span class="number">1</span>); <span class="comment">% 步长记录</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">% 生成时变系统输出</span></span><br><span class="line">    <span class="keyword">for</span> n = L:N</span><br><span class="line">        <span class="comment">% 系统切换检测</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">500</span></span><br><span class="line">            <span class="built_in">true</span>_coef = <span class="built_in">true</span>_coef1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">true</span>_coef = <span class="built_in">true</span>_coef2;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">% 生成期望信号</span></span><br><span class="line">        x_vec = x(n:<span class="number">-1</span>:n-L+<span class="number">1</span>);</span><br><span class="line">        d(n) = <span class="built_in">true</span>_coef&#x27; * x_vec + v(n);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% LMS算法执行</span></span><br><span class="line">    <span class="keyword">for</span> n = L:N<span class="number">-1</span></span><br><span class="line">        <span class="comment">% 当前输入向量</span></span><br><span class="line">        x_vec = x(n:<span class="number">-1</span>:n-L+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">% 滤波器输出</span></span><br><span class="line">        y = w&#x27; * x_vec;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">% 误差计算</span></span><br><span class="line">        e(n) = d(n) - y;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">% Sigmoid变步长计算</span></span><br><span class="line">        mu = <span class="built_in">beta</span> * (<span class="number">1</span>/(<span class="number">1</span> + <span class="built_in">exp</span>(-alpha*(<span class="built_in">abs</span>(e(n)))^<span class="number">3</span>)) - <span class="number">0.5</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">% 系数更新</span></span><br><span class="line">        w = w + mu * e(n) * x_vec;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">% 记录步长</span></span><br><span class="line">        mu_history(n) = mu;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 累积数据</span></span><br><span class="line">    mu_avg = mu_avg + mu_history;</span><br><span class="line">    e_avg = e_avg + <span class="built_in">abs</span>(e);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 数据后处理</span></span><br><span class="line">mu_avg = mu_avg / trials;</span><br><span class="line">e_avg = e_avg / trials;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 结果可视化</span></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(mu_avg, <span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1.5</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;迭代次数&#x27;</span>); ylabel(<span class="string">&#x27;步长均值&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;步长变化曲线&#x27;</span>);</span><br><span class="line">grid on;</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">semilogy(e_avg, <span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1.5</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;迭代次数&#x27;</span>); ylabel(<span class="string">&#x27;|误差|均值&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;误差收敛曲线&#x27;</span>);</span><br><span class="line">grid on;</span><br></pre></td></tr></table></figure><h2 id="SVSLMS算法改进仿真2"><a href="#SVSLMS算法改进仿真2" class="headerlink" title="SVSLMS算法改进仿真2"></a>SVSLMS算法改进仿真2</h2><p>$\mu (n)&#x3D;\beta (1-\frac{h+2}{h+exp(-\alpha |e(n-1)|^\gamma)+exp(\alpha |e(n)|^\gamma)})$</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% [29]陈泳,田金鹏,刘燕平. 一种新的变步长LMS自适应滤波算法[J]. 电子测量技术,2015,38(4):27-31.</span></span><br><span class="line"></span><br><span class="line">clear; clc; close all;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 参数设置</span></span><br><span class="line">L = <span class="number">2</span>;                  <span class="comment">% 滤波器阶数</span></span><br><span class="line"><span class="built_in">true</span>_coef1 = [<span class="number">0.8</span>; <span class="number">0.5</span>];<span class="comment">% 初始真实系数</span></span><br><span class="line"><span class="built_in">true</span>_coef2 = [<span class="number">0.4</span>; <span class="number">0.2</span>];<span class="comment">% 500点后切换的真实系数</span></span><br><span class="line">N = <span class="number">1000</span>;               <span class="comment">% 采样点数</span></span><br><span class="line">trials = <span class="number">200</span>;           <span class="comment">% 独立实验次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 新的变步长参数</span></span><br><span class="line">alpha = <span class="number">3.5</span>;            <span class="comment">% Sigmoid相关系数</span></span><br><span class="line"><span class="built_in">beta</span> = <span class="number">0.028</span>;           <span class="comment">% 步长缩放因子</span></span><br><span class="line"><span class="built_in">gamma</span> = <span class="number">2</span>;              <span class="comment">% 指数参数</span></span><br><span class="line">h = <span class="number">2</span>;                  <span class="comment">% 常数参数</span></span><br><span class="line"></span><br><span class="line">noise_var = <span class="number">0.04</span>;       <span class="comment">% 噪声方差</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 预分配存储空间</span></span><br><span class="line">mu_avg = <span class="built_in">zeros</span>(N,<span class="number">1</span>);    <span class="comment">% 平均步长</span></span><br><span class="line">e_avg = <span class="built_in">zeros</span>(N,<span class="number">1</span>);     <span class="comment">% 平均误差</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 主循环（200次独立实验）</span></span><br><span class="line"><span class="keyword">for</span> trial = <span class="number">1</span>:trials</span><br><span class="line">    <span class="comment">% 生成测试信号</span></span><br><span class="line">    x = <span class="built_in">randn</span>(N,<span class="number">1</span>);                     <span class="comment">% 高斯白噪声，方差1</span></span><br><span class="line">    v = <span class="built_in">sqrt</span>(noise_var)*<span class="built_in">randn</span>(N,<span class="number">1</span>);     <span class="comment">% 干扰噪声</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">% 初始化变量</span></span><br><span class="line">    w = <span class="built_in">zeros</span>(L,<span class="number">1</span>);     <span class="comment">% 自适应滤波器系数</span></span><br><span class="line">    d = <span class="built_in">zeros</span>(N,<span class="number">1</span>);     <span class="comment">% 期望信号</span></span><br><span class="line">    e = <span class="built_in">zeros</span>(N,<span class="number">1</span>);     <span class="comment">% 误差信号</span></span><br><span class="line">    mu_history = <span class="built_in">zeros</span>(N,<span class="number">1</span>); <span class="comment">% 步长记录</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">% 生成时变系统输出</span></span><br><span class="line">    <span class="keyword">for</span> n = L:N</span><br><span class="line">        <span class="comment">% 系统切换检测：前500点采用true_coef1，之后使用true_coef2</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">500</span></span><br><span class="line">            <span class="built_in">true</span>_coef = <span class="built_in">true</span>_coef1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">true</span>_coef = <span class="built_in">true</span>_coef2;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">% 期望信号生成</span></span><br><span class="line">        x_vec = x(n:<span class="number">-1</span>:n-L+<span class="number">1</span>);</span><br><span class="line">        d(n) = <span class="built_in">true</span>_coef&#x27; * x_vec + v(n);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">% LMS算法执行</span></span><br><span class="line">    <span class="keyword">for</span> n = L:N<span class="number">-1</span></span><br><span class="line">        <span class="comment">% 当前输入向量</span></span><br><span class="line">        x_vec = x(n:<span class="number">-1</span>:n-L+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">% 滤波器输出</span></span><br><span class="line">        y = w&#x27; * x_vec;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">% 误差</span></span><br><span class="line">        e(n) = d(n) - y;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">% 新的变步长公式</span></span><br><span class="line">        <span class="keyword">if</span> n == L</span><br><span class="line">            <span class="comment">% 第一点时无e(n-1)，只使用e(n)</span></span><br><span class="line">            mu = <span class="built_in">beta</span> * (<span class="number">1</span> - (h + <span class="number">2</span>) / (h + <span class="built_in">exp</span>(alpha * <span class="built_in">abs</span>(e(n))^<span class="built_in">gamma</span>)));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">% 完整步长公式</span></span><br><span class="line">            mu = <span class="built_in">beta</span> * (<span class="number">1</span> - (h + <span class="number">2</span>) / (h + <span class="built_in">exp</span>(-alpha * <span class="built_in">abs</span>(e(n<span class="number">-1</span>))^<span class="built_in">gamma</span>) + <span class="built_in">exp</span>(alpha * <span class="built_in">abs</span>(e(n))^<span class="built_in">gamma</span>)));</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">% 系数更新</span></span><br><span class="line">        w = w + mu * e(n) * x_vec;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">% 记录步长</span></span><br><span class="line">        mu_history(n) = mu;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 多次实验结果累加</span></span><br><span class="line">    mu_avg = mu_avg + mu_history;</span><br><span class="line">    e_avg = e_avg + <span class="built_in">abs</span>(e);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 数据后处理：取平均</span></span><br><span class="line">mu_avg = mu_avg / trials;</span><br><span class="line">e_avg = e_avg / trials;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 结果可视化</span></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(mu_avg, <span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1.5</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;迭代次数&#x27;</span>); ylabel(<span class="string">&#x27;步长均值&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;步长变化曲线&#x27;</span>);</span><br><span class="line">grid on;</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">semilogy(e_avg, <span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1.5</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;迭代次数&#x27;</span>); ylabel(<span class="string">&#x27;|误差|均值&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;误差收敛曲线&#x27;</span>);</span><br><span class="line">grid on;</span><br></pre></td></tr></table></figure><h2 id="SVSLMS算法改进仿真3"><a href="#SVSLMS算法改进仿真3" class="headerlink" title="SVSLMS算法改进仿真3"></a>SVSLMS算法改进仿真3</h2><p>$\mu (n)&#x3D;\beta [\frac{1}{4}-\frac{exp(-\alpha|e(n)|)}{(1+exp(-\alpha|e(n)|))^2}]$</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% [30]仝喜峰,陈卫松,钱隆彦,等. 一种非线性变步长LMS自适应滤波算法[J]. 无线电通信技术,2019,45(4):391-396.</span></span><br><span class="line"></span><br><span class="line">clear; clc; close all;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 参数设置</span></span><br><span class="line">L = <span class="number">2</span>;                  <span class="comment">% 滤波器阶数</span></span><br><span class="line"><span class="built_in">true</span>_coef1 = [<span class="number">0.8</span>; <span class="number">0.5</span>];<span class="comment">% 初始真实系数</span></span><br><span class="line"><span class="built_in">true</span>_coef2 = [<span class="number">0.4</span>; <span class="number">0.2</span>];<span class="comment">% 500点后系数</span></span><br><span class="line">N = <span class="number">1000</span>;               <span class="comment">% 采样点数</span></span><br><span class="line">trials = <span class="number">200</span>;           <span class="comment">% 独立实验次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 更新后的变步长参数</span></span><br><span class="line">alpha = <span class="number">3</span>;             <span class="comment">% 用于新公式的参数</span></span><br><span class="line"><span class="built_in">beta</span> = <span class="number">0.5</span>;              <span class="comment">% 步长缩放因子</span></span><br><span class="line"></span><br><span class="line">noise_var = <span class="number">0.04</span>;       <span class="comment">% 噪声方差</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 预分配存储空间</span></span><br><span class="line">mu_avg = <span class="built_in">zeros</span>(N,<span class="number">1</span>);    <span class="comment">% 平均步长</span></span><br><span class="line">e_avg = <span class="built_in">zeros</span>(N,<span class="number">1</span>);     <span class="comment">% 平均误差</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 主循环（200次独立实验）</span></span><br><span class="line"><span class="keyword">for</span> trial = <span class="number">1</span>:trials</span><br><span class="line">    <span class="comment">% 生成信号</span></span><br><span class="line">    x = <span class="built_in">randn</span>(N,<span class="number">1</span>);                       <span class="comment">% 方差1的高斯白噪声</span></span><br><span class="line">    v = <span class="built_in">sqrt</span>(noise_var)*<span class="built_in">randn</span>(N,<span class="number">1</span>);       <span class="comment">% 干扰噪声</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 初始化变量</span></span><br><span class="line">    w = <span class="built_in">zeros</span>(L,<span class="number">1</span>);     <span class="comment">% 滤波器系数</span></span><br><span class="line">    d = <span class="built_in">zeros</span>(N,<span class="number">1</span>);     <span class="comment">% 期望信号</span></span><br><span class="line">    e = <span class="built_in">zeros</span>(N,<span class="number">1</span>);     <span class="comment">% 误差信号</span></span><br><span class="line">    mu_history = <span class="built_in">zeros</span>(N,<span class="number">1</span>); <span class="comment">% 步长记录</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">% 生成时变系统输出</span></span><br><span class="line">    <span class="keyword">for</span> n = L:N</span><br><span class="line">        <span class="comment">% 系统切换检测（前500点使用true_coef1，之后使用true_coef2）</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">500</span></span><br><span class="line">            <span class="built_in">true</span>_coef = <span class="built_in">true</span>_coef1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">true</span>_coef = <span class="built_in">true</span>_coef2;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">% 期望信号生成</span></span><br><span class="line">        x_vec = x(n:<span class="number">-1</span>:n-L+<span class="number">1</span>);</span><br><span class="line">        d(n) = <span class="built_in">true</span>_coef&#x27; * x_vec + v(n);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% LMS算法执行</span></span><br><span class="line">    <span class="keyword">for</span> n = L:N<span class="number">-1</span></span><br><span class="line">        <span class="comment">% 当前输入向量</span></span><br><span class="line">        x_vec = x(n:<span class="number">-1</span>:n-L+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">% 滤波器输出</span></span><br><span class="line">        y = w&#x27; * x_vec;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">% 误差计算</span></span><br><span class="line">        e(n) = d(n) - y;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">% 使用新的变步长公式:</span></span><br><span class="line">        <span class="comment">% mu(n) = β * [ 1/4 - exp(-α|e(n)|) / (1 + exp(-α|e(n)|))^2 ]</span></span><br><span class="line">        mu = <span class="built_in">beta</span> * ( <span class="number">1</span>/<span class="number">4</span> - <span class="built_in">exp</span>(-alpha * <span class="built_in">abs</span>(e(n))) / ( (<span class="number">1</span> + <span class="built_in">exp</span>(-alpha * <span class="built_in">abs</span>(e(n))))^<span class="number">2</span> ) );</span><br><span class="line">        </span><br><span class="line">        <span class="comment">% 系数更新</span></span><br><span class="line">        w = w + mu * e(n) * x_vec;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">% 记录步长</span></span><br><span class="line">        mu_history(n) = mu;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 累积数据</span></span><br><span class="line">    mu_avg = mu_avg + mu_history;</span><br><span class="line">    e_avg = e_avg + <span class="built_in">abs</span>(e);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 数据后处理</span></span><br><span class="line">mu_avg = mu_avg / trials;</span><br><span class="line">e_avg = e_avg / trials;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 结果可视化</span></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(mu_avg, <span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1.5</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;迭代次数&#x27;</span>); ylabel(<span class="string">&#x27;步长均值&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;步长变化曲线&#x27;</span>);</span><br><span class="line">grid on;</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">semilogy(e_avg, <span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1.5</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;迭代次数&#x27;</span>); ylabel(<span class="string">&#x27;|误差|均值&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;误差收敛曲线&#x27;</span>);</span><br><span class="line">grid on;</span><br></pre></td></tr></table></figure><h1 id="改进算法"><a href="#改进算法" class="headerlink" title="改进算法"></a>改进算法</h1><p>$\alpha (n)&#x3D;\alpha_0(1-e^{-\gamma |e(n)})$</p><p>$\beta (n)&#x3D;\beta _{max}-(\beta _{max}-\beta _{min})e^{-\eta |e(n)}$</p><p>$\mu (n)&#x3D;\beta (\frac{1}{1+e^{-\alpha \left | e(x) \right | } } -0.5)$</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear; clc; close all;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 参数设置</span></span><br><span class="line">L = <span class="number">2</span>;                  <span class="comment">% 滤波器阶数</span></span><br><span class="line"><span class="built_in">true</span>_coef1 = [<span class="number">0.8</span>; <span class="number">0.5</span>];<span class="comment">% 初始真实系数</span></span><br><span class="line"><span class="built_in">true</span>_coef2 = [<span class="number">0.8</span>; <span class="number">0.5</span>];<span class="comment">% 500点后系数</span></span><br><span class="line">N = <span class="number">1000</span>;               <span class="comment">% 采样点数</span></span><br><span class="line">trials = <span class="number">200</span>;           <span class="comment">% 独立实验次数</span></span><br><span class="line">noise_var = <span class="number">0.04</span>;       <span class="comment">% 噪声方差</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 新增：动态调整相关参数常数</span></span><br><span class="line">alpha0   = <span class="number">1.5</span>;         <span class="comment">% alpha(n)的最大基准值</span></span><br><span class="line">beta_min = <span class="number">0.1</span>;         <span class="comment">% beta(n)下限</span></span><br><span class="line">beta_max = <span class="number">0.8</span>;         <span class="comment">% beta(n)上限</span></span><br><span class="line"><span class="built_in">gamma</span>    = <span class="number">2</span>;         <span class="comment">% alpha(n)指数调节因子</span></span><br><span class="line">eta      = <span class="number">10</span>;         <span class="comment">% beta(n)指数调节因子</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 预分配存储空间</span></span><br><span class="line">mu_avg = <span class="built_in">zeros</span>(N,<span class="number">1</span>);    <span class="comment">% 平均步长</span></span><br><span class="line">e_avg = <span class="built_in">zeros</span>(N,<span class="number">1</span>);     <span class="comment">% 平均误差</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 主循环（200次独立实验）</span></span><br><span class="line"><span class="keyword">for</span> trial = <span class="number">1</span>:trials</span><br><span class="line">    <span class="comment">% 生成信号</span></span><br><span class="line">    x = <span class="built_in">randn</span>(N,<span class="number">1</span>);                      <span class="comment">% 方差1的高斯白噪声</span></span><br><span class="line">    v = <span class="built_in">sqrt</span>(noise_var)*<span class="built_in">randn</span>(N,<span class="number">1</span>);      <span class="comment">% 干扰噪声</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 初始化变量</span></span><br><span class="line">    w = <span class="built_in">zeros</span>(L,<span class="number">1</span>);                      <span class="comment">% 滤波器系数</span></span><br><span class="line">    d = <span class="built_in">zeros</span>(N,<span class="number">1</span>);                      <span class="comment">% 期望信号</span></span><br><span class="line">    e = <span class="built_in">zeros</span>(N,<span class="number">1</span>);                      <span class="comment">% 误差信号</span></span><br><span class="line">    mu_history = <span class="built_in">zeros</span>(N,<span class="number">1</span>);             <span class="comment">% 步长记录</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">% 生成时变系统输出</span></span><br><span class="line">    <span class="keyword">for</span> n = L:N</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">500</span></span><br><span class="line">            <span class="built_in">true</span>_coef = <span class="built_in">true</span>_coef1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">true</span>_coef = <span class="built_in">true</span>_coef2;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        x_vec = x(n:<span class="number">-1</span>:n-L+<span class="number">1</span>);</span><br><span class="line">        d(n) = <span class="built_in">true</span>_coef&#x27; * x_vec + v(n);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 改进的变步长LMS算法</span></span><br><span class="line">    <span class="keyword">for</span> n = L:N<span class="number">-1</span></span><br><span class="line">        x_vec = x(n:<span class="number">-1</span>:n-L+<span class="number">1</span>);</span><br><span class="line">        y = w&#x27; * x_vec;</span><br><span class="line">        e(n) = d(n) - y;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">% 动态调节alpha与beta</span></span><br><span class="line">        alpha_n = alpha0 * (<span class="number">1</span> - <span class="built_in">exp</span>(-<span class="built_in">gamma</span>*<span class="built_in">abs</span>(e(n))));</span><br><span class="line">        beta_n  = beta_max - (beta_max - beta_min)*<span class="built_in">exp</span>(-eta*<span class="built_in">abs</span>(e(n)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">% 变步长更新</span></span><br><span class="line">        mu = beta_n * (<span class="number">1</span>/(<span class="number">1</span> + <span class="built_in">exp</span>(-alpha_n*<span class="built_in">abs</span>(e(n)))) - <span class="number">0.5</span>);</span><br><span class="line">        w = w + mu * e(n) * x_vec;</span><br><span class="line">        </span><br><span class="line">        mu_history(n) = mu;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 累积数据</span></span><br><span class="line">    mu_avg = mu_avg + mu_history;</span><br><span class="line">    e_avg = e_avg + <span class="built_in">abs</span>(e);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 数据后处理</span></span><br><span class="line">mu_avg = mu_avg / trials;</span><br><span class="line">e_avg = e_avg / trials;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 结果可视化</span></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(mu_avg, <span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1.5</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;迭代次数&#x27;</span>); ylabel(<span class="string">&#x27;步长均值&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;步长变化曲线&#x27;</span>);</span><br><span class="line">grid on;</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">semilogy(e_avg, <span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1.5</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;迭代次数&#x27;</span>); ylabel(<span class="string">&#x27;|误差|均值&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;误差收敛曲线&#x27;</span>);</span><br><span class="line">grid on;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本科毕业设计主要代码工作</summary>
    
    
    
    <category term="自动化" scheme="https://striver98.github.io/categories/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    
    <category term="自适应滤波" scheme="https://striver98.github.io/tags/%E8%87%AA%E9%80%82%E5%BA%94%E6%BB%A4%E6%B3%A2/"/>
    
    <category term="毕设" scheme="https://striver98.github.io/tags/%E6%AF%95%E8%AE%BE/"/>
    
  </entry>
  
  <entry>
    <title>PyTorch学习记录</title>
    <link href="https://striver98.github.io/2025/01/10/PyTorch%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>https://striver98.github.io/2025/01/10/PyTorch%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</id>
    <published>2025-01-10T02:48:31.000Z</published>
    <updated>2025-01-10T02:48:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章-PyTorch基础配置与介绍"><a href="#第一章-PyTorch基础配置与介绍" class="headerlink" title="第一章 PyTorch基础配置与介绍"></a>第一章 PyTorch基础配置与介绍</h1><h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><ul><li>Python3.9</li><li>PyTorch 2.4.1</li><li>CUDA 12.1</li><li>NVIDIA GeForce RTX 4060 Laptop GPU</li></ul><h2 id="Anaconda常用命令"><a href="#Anaconda常用命令" class="headerlink" title="Anaconda常用命令"></a>Anaconda常用命令</h2><ul><li><p>创建环境：conda create -n your_env_name python&#x3D;X.X （X.X为python版本）</p><p>eg: conda create -n pytorch_tutorial python&#x3D;3.7</p></li><li><p>激活环境：source activate your_env_name</p><p>eg: source activate pytorch_tutorial</p></li><li><p>退出环境：source deactivate</p></li><li><p>删除环境：conda remove -n your_env_name –all</p><p>eg: conda remove -n pytorch_tutorial –all</p></li><li><p>查看已有虚拟环境：conda env list &#x2F; conda info -e</p></li></ul><h2 id="PyCharm常用快捷键"><a href="#PyCharm常用快捷键" class="headerlink" title="PyCharm常用快捷键"></a>PyCharm常用快捷键</h2><ul><li>批量注释：Ctrl + &#x2F;</li><li>快速查看文档：Ctrl + q</li><li>搜索：Ctrl+f</li><li>运行：Shift + F10</li><li>Tab &#x2F; Shift + Tab 缩进、不缩进当前行</li><li>Ctrl + D 复制选定的区域或行</li><li>Ctrl + Y 删除选定的行</li></ul><h2 id="JupyterNotebook常用快捷键"><a href="#JupyterNotebook常用快捷键" class="headerlink" title="JupyterNotebook常用快捷键"></a>JupyterNotebook常用快捷键</h2><p><strong>命令模式：</strong></p><ul><li>插入单元格： A 键上方插入，B 键在下方插入</li><li>合并单元格：选中多个单元格，Shift + M</li><li>显示行号：L</li><li>删除单元格：连续按两次D</li><li>剪切单元格：X。 通常我用X代替删除，毕竟只用按一个键，哈哈。</li><li>复制粘贴单元格： C&#x2F;V</li><li>撤销删除的单元格：要撤消已删除的单元格，请按 Z 键</li></ul><p><strong>编辑模式：</strong></p><ul><li><strong>运行单元格</strong>：Ctrl + Enter</li><li><strong>运行并创建新单元格</strong>：Alt + Enter</li><li>分割单元格：光标放到想要分割的地方，Ctrl + Shift + -</li><li>函数详情：Shift+Tab （注意，要把模块导入才会提示函数详情！）</li></ul>]]></content>
    
    
    <summary type="html">基于《PyTorch实用教程第二版》的学习笔记</summary>
    
    
    
    <category term="人工智能" scheme="https://striver98.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="Python" scheme="https://striver98.github.io/tags/Python/"/>
    
    <category term="PyTorch" scheme="https://striver98.github.io/tags/PyTorch/"/>
    
    <category term="深度学习" scheme="https://striver98.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>最优控制之动态规划</title>
    <link href="https://striver98.github.io/2025/01/01/%E6%9C%80%E4%BC%98%E6%8E%A7%E5%88%B6%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>https://striver98.github.io/2025/01/01/%E6%9C%80%E4%BC%98%E6%8E%A7%E5%88%B6%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2025-01-01T12:46:20.000Z</published>
    <updated>2025-01-01T12:46:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><ol><li><p><strong>代价函数（cost function）</strong>：$J&#x3D;(x_{N}-x_{d})^{T}S(x_{N}-x_{d})&#x3D;\parallel x_{N}-x_{d} \parallel _{S}^{2} $ </p><ul><li>S为半正定对称的权重矩阵（常为对角矩阵），调整权重矩阵中的参数决定了不同状态变量在性能指标中的重要程度。</li></ul></li><li><p><strong>控制策略（control policy）</strong>：$ U^{*}&#x3D;argmin\mathit{J}$</p></li><li><p>约束条件：</p><ul><li><strong>硬约束（hard constraints）</strong>：$u_{min[k]}\le u_{[k]}\le u_{max[k]}$，是在系统控制中必须满足的约束条件。</li><li><strong>软约束（soft constraints）</strong>：$J&#x3D;\parallel x_{N}-x_{d} \parallel <em>{S}^{2} + \sum</em>{k&#x3D;0}^{N-1} \parallel u_{k} \parallel  <em>{R</em>{[k]}}^{2}$ ，其中下标$R_{[k]}$表示控制量的权重系数矩阵，是一个正定的对称矩阵（常为对角矩阵），可以随着时间k进行变化，引入了对控制输入的约束。</li><li><strong>运行代价（stage cost）</strong>：$J&#x3D;\parallel x_{N}-x_{d} \parallel <em>{S}^{2} +\sum</em>{k&#x3D;0}^{N-1} \parallel x_{[k]}-x_{d_{[k]}} \parallel  <em>{Q</em>{[k]}}^{2}+\sum_{k&#x3D;0}^{N-1} \parallel u_{k} \parallel  <em>{R</em>{[k]}}^{2}$，其中$Q_{[k]}$表示运行代价的权重矩阵，为半正定的对称矩阵（常为对角矩阵），来衡量每个时间步的状态变量与目标轨迹之间的差异。</li></ul></li><li><p>最优控制的目标是找到合适的控制策略，使得性能指标<strong>J</strong>最小。</p></li></ol><h1 id="数值方法"><a href="#数值方法" class="headerlink" title="数值方法"></a>数值方法</h1><h2 id="举例：无人机高度控制"><a href="#举例：无人机高度控制" class="headerlink" title="举例：无人机高度控制"></a>举例：无人机高度控制</h2><ul><li>动态方程：$m\frac{d^{2}h_{(t)}}{dt^{2}}&#x3D;f_{(t)}-mg$</li><li>输入：$u_{(t)}&#x3D;\frac{f_{(t)}}{m}$</li><li>状态变量：$x_{(t)}&#x3D;\begin{bmatrix}x_{1_{(t)}}\x_{2_{(t)}}\end{bmatrix}$，其中$x_{1_{(t)}}&#x3D;h_{(t)}$，表示高度；$x_{2_{(t)}}&#x3D;\frac{dh_{(t)}}{dt}$，表示速度。</li><li>设无人机重量为m&#x3D;1kg，重力加速度为$g&#x3D;10m&#x2F;s^{2}$</li><li>无人机的加速度$u_{a_{(t)}}&#x3D;(u_{(t)}-10)$</li><li>无人机从地面上升到10m，并保证无人机在静止位置出发，达到目标高度的同时速度降为0。$t_{0}$为初始时间，$t_{f}$为末端时间。</li><li>约束条件：$-3m&#x2F;s^{2} \le u_{a_{(t)}} \le 2m&#x2F;s^{2}$，$0m&#x2F;s \le x_{2_{(t)}} \le 3m&#x2F;s$</li></ul><h2 id="逆向分级求解方法"><a href="#逆向分级求解方法" class="headerlink" title="逆向分级求解方法"></a>逆向分级求解方法</h2><p>设每一级之间的距离为2m，在离散系统中，控制量 $u_{a_{(t)}}$在两极之间保持不变，即无人机加速度保持不变，因此速度的变化是线性的。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">%% 《控制之美-卷二》 代码</span></span><br><span class="line"><span class="comment">%% 作者：王天威，黄军魁</span></span><br><span class="line"><span class="comment">%% 清华大学出版社</span></span><br><span class="line"><span class="comment">%% 程序名称：LQR_UAV_tracking_SS_U</span></span><br><span class="line"><span class="comment">%% 程序功能：无人机上升目标高度最短用时控制-动态规划数值方法 （4.2节案例）</span></span><br><span class="line"><span class="comment">%% 理论基础：贝尔曼最优化理论</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 程序初始化，清空工作空间，缓存</span></span><br><span class="line">clear all;</span><br><span class="line">close all;</span><br><span class="line">clc;</span><br><span class="line"></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%系统初始化%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 无人机高度初始化</span></span><br><span class="line">h_init = <span class="number">0</span> ;</span><br><span class="line"><span class="comment">% 无人机速度初始化</span></span><br><span class="line">v_init = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%系统终值定义%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 无人机终点高度</span></span><br><span class="line">h_final = <span class="number">10</span>;</span><br><span class="line"><span class="comment">% 无人机终点速度</span></span><br><span class="line">v_final = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%边界条件定义%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 高度下限</span></span><br><span class="line">h_min = <span class="number">0</span>;</span><br><span class="line"><span class="comment">% 高度上限</span></span><br><span class="line">h_max = <span class="number">10</span>;</span><br><span class="line"><span class="comment">% 高度离散数（可修改）</span></span><br><span class="line">N_h = <span class="number">10</span>;</span><br><span class="line"><span class="comment">% 速度下限</span></span><br><span class="line">v_min = <span class="number">0</span>;</span><br><span class="line"><span class="comment">% 速度上限</span></span><br><span class="line">v_max = <span class="number">3</span>;</span><br><span class="line"><span class="comment">% 速度离散数（可修改）</span></span><br><span class="line">N_v = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%创建离散向量%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 高度向量</span></span><br><span class="line">Hd = h_min : (h_max - h_min)/N_h: h_max;</span><br><span class="line"><span class="comment">% 速度向量</span></span><br><span class="line">Vd = v_min: (v_max - v_min)/N_v : v_max;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 无人机加速度上下限设置</span></span><br><span class="line">u_min = <span class="number">-3</span>; u_max = <span class="number">2</span>;</span><br><span class="line"><span class="comment">% 定义初始剩余代价矩阵</span></span><br><span class="line">J_costtogo = <span class="built_in">zeros</span>(N_h + <span class="number">1</span>, N_v + <span class="number">1</span>);</span><br><span class="line"><span class="comment">% 定义系统输入矩阵</span></span><br><span class="line">Input_acc = <span class="built_in">zeros</span>(N_h + <span class="number">1</span>, N_v + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%计算最后一级的情况%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 计算最后一级至上一级间平均速度矩阵</span></span><br><span class="line">v_avg = <span class="number">0.5</span> * (v_final + Vd);</span><br><span class="line"><span class="comment">% 计算最后一级至上一级间用时矩阵</span></span><br><span class="line">T_delta = (h_max - h_min)./(N_h * v_avg);</span><br><span class="line"><span class="comment">% 计算最后一级至上一级间加速度矩阵</span></span><br><span class="line">acc = (v_final - Vd)./T_delta;</span><br><span class="line"><span class="comment">% 将用时存入代价矩阵</span></span><br><span class="line">J_temp = T_delta;</span><br><span class="line"><span class="comment">% 筛选超限的系统输入（加速度需满足上下限）</span></span><br><span class="line">[acc_x,acc_y] = <span class="built_in">find</span>(acc &lt; u_min | acc &gt; u_max);</span><br><span class="line"><span class="comment">% 通过线性检索命令找到加速度超限的位置</span></span><br><span class="line">Ind_lin_acc = <span class="built_in">sub2ind</span> (<span class="built_in">size</span>(acc),acc_x,acc_y);</span><br><span class="line"><span class="comment">% 将加速度超限位置的系统代价人为赋值为无穷大</span></span><br><span class="line">J_temp (Ind_lin_acc) = <span class="built_in">inf</span>;</span><br><span class="line"><span class="comment">% 将更新的代价存入相应的剩余代价矩阵的对应元素的位置</span></span><br><span class="line">J_costtogo(<span class="number">2</span>,:) = J_temp;</span><br><span class="line"><span class="comment">% 将对应的加速度存入系统输入矩阵的相应位置</span></span><br><span class="line">Input_acc(<span class="number">2</span>,:) = acc;</span><br><span class="line"></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%倒数第二级至第二级的情况%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 设计for循环进行逆向级间的更新 （参考图4.2.7）</span></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">3</span> : <span class="number">1</span> : N_h</span><br><span class="line"><span class="comment">% 构建速度方阵，代表相邻两级间速度的所有组合</span></span><br><span class="line">[Vd_x, Vd_y] = <span class="built_in">meshgrid</span>(Vd , Vd);</span><br><span class="line"><span class="comment">% 计算级间平均速度矩阵</span></span><br><span class="line">v_avg = <span class="number">0.5</span> * (Vd_x + Vd_y);</span><br><span class="line"><span class="comment">% 计算级间用时矩阵，这也是级间代价矩阵</span></span><br><span class="line">T_delta = (h_max - h_min)./(N_h * v_avg);</span><br><span class="line"><span class="comment">% 计算级间加速度矩阵</span></span><br><span class="line">acc = (Vd_y - Vd_x)./T_delta;</span><br><span class="line"><span class="comment">% 将级间用时赋值代价矩阵</span></span><br><span class="line">J_temp = T_delta;</span><br><span class="line"><span class="comment">% 筛选超限的系统输入（加速度需满足上下限）</span></span><br><span class="line">[acc_x, acc_y] = <span class="built_in">find</span>(acc &lt; u_min | acc &gt; u_max);</span><br><span class="line"><span class="comment">% 通过线性检索命令找到加速度超限的位置</span></span><br><span class="line">Ind_lin_acc = <span class="built_in">sub2ind</span> (<span class="built_in">size</span>(acc),acc_x,acc_y);</span><br><span class="line"><span class="comment">% 将加速度超限位置的系统代价人为赋值为无穷大</span></span><br><span class="line">J_temp (Ind_lin_acc) = <span class="built_in">inf</span>;</span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%% 重要的步骤! %%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 生成代价矩阵，注意需要将临时代价与上一步的剩余代价结合（注意要转置&#x27;）</span></span><br><span class="line">J_temp = J_temp + <span class="built_in">meshgrid</span>(J_costtogo(k<span class="number">-1</span>,:))&#x27;;</span><br><span class="line"><span class="comment">% 提取剩余代价矩阵的最小值</span></span><br><span class="line">[J_costtogo(k,:), l] = <span class="built_in">min</span>(J_temp) ;</span><br><span class="line"><span class="comment">% 线性索引找到最小值的位置</span></span><br><span class="line">Ind_lin_acc = <span class="built_in">sub2ind</span> (<span class="built_in">size</span>(J_temp), l, <span class="number">1</span>:<span class="built_in">length</span>(l));</span><br><span class="line"><span class="comment">% 保存相应的系统输入</span></span><br><span class="line">Input_acc (k,:) = acc(Ind_lin_acc) ;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%第二级至第一级的情况%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 计算级间平均速度矩阵</span></span><br><span class="line">v_avg = <span class="number">0.5</span> * (Vd + v_init);</span><br><span class="line"><span class="comment">% 计算级间用时矩阵</span></span><br><span class="line">T_delta = (h_max - h_min)./(N_h * v_avg);</span><br><span class="line"><span class="comment">% 计算级间加速度矩阵</span></span><br><span class="line">acc = (Vd - v_init)./T_delta;</span><br><span class="line"><span class="comment">% 级间用时存入临时代价矩阵</span></span><br><span class="line">J_temp = T_delta;</span><br><span class="line"><span class="comment">% 筛选超限的系统输入（加速度需满足上下限）</span></span><br><span class="line">[acc_x, acc_y] = <span class="built_in">find</span>(acc &lt; u_min | acc &gt; u_max);</span><br><span class="line"><span class="comment">% 通过线性检索命令找到加速度超限的位置</span></span><br><span class="line">Ind_lin_acc = <span class="built_in">sub2ind</span> (<span class="built_in">size</span>(acc),acc_x,acc_y);</span><br><span class="line"><span class="comment">% 将加速度超限位置的系统代价人为赋值为无穷大</span></span><br><span class="line">J_temp (Ind_lin_acc) = <span class="built_in">inf</span>; <span class="comment">% Let certain elements to infitiy</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%% 重要的步骤! %%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 生成代价矩阵，注意需要将临时代价与上一步的剩余代价结合</span></span><br><span class="line">J_temp = J_temp + J_costtogo(N_h,:);</span><br><span class="line"><span class="comment">% 提取剩余代价矩阵的最小值</span></span><br><span class="line">[J_costtogo(N_h+<span class="number">1</span>,<span class="number">1</span>), l] = <span class="built_in">min</span>(J_temp);</span><br><span class="line"><span class="comment">% 线性索引找到最小值的位置</span></span><br><span class="line">Ind_lin_acc = <span class="built_in">sub2ind</span> (<span class="built_in">size</span>(J_temp), l);</span><br><span class="line"><span class="comment">% 保存相应的系统输入</span></span><br><span class="line">Input_acc (N_h+<span class="number">1</span>,<span class="number">1</span>) = acc(Ind_lin_acc);</span><br><span class="line"></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%结果（画图）%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% 初始化高度</span></span><br><span class="line">h_plot_init = <span class="number">0</span>;</span><br><span class="line"><span class="comment">% 初始化速度</span></span><br><span class="line">v_plot_init = <span class="number">0</span>;</span><br><span class="line"><span class="comment">% 初始化时间</span></span><br><span class="line">t_plot_init = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 定义加速度结果维度</span></span><br><span class="line">acc_plot = <span class="built_in">zeros</span>(<span class="built_in">length</span>(Hd),<span class="number">1</span>);</span><br><span class="line"><span class="comment">% 定义速度结果维度</span></span><br><span class="line">v_plot = <span class="built_in">zeros</span>(<span class="built_in">length</span>(Hd),<span class="number">1</span>);</span><br><span class="line"><span class="comment">% 定义高度结果维度</span></span><br><span class="line">h_plot = <span class="built_in">zeros</span>(<span class="built_in">length</span>(Hd),<span class="number">1</span>);</span><br><span class="line"><span class="comment">% 定义时间维度</span></span><br><span class="line">t_plot  = <span class="built_in">zeros</span>(<span class="built_in">length</span>(Hd),<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 定义高度初值</span></span><br><span class="line">h_plot (<span class="number">1</span>) = h_plot_init;</span><br><span class="line"><span class="comment">% 定义速度初值</span></span><br><span class="line">v_plot (<span class="number">1</span>) = v_plot_init;</span><br><span class="line"><span class="comment">% 定义时间初值</span></span><br><span class="line">t_plot (<span class="number">1</span>) = t_plot_init;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 查表确定最优路线</span></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span> : <span class="number">1</span> : N_h</span><br><span class="line"><span class="comment">% 确认高度最优索引</span></span><br><span class="line">[min_h,h_plot_index] = <span class="built_in">min</span>(<span class="built_in">abs</span>(h_plot(k) - Hd));</span><br><span class="line"><span class="comment">% 群人速度最优索引</span></span><br><span class="line">[min_v,v_plot_index] = <span class="built_in">min</span>(<span class="built_in">abs</span>(v_plot(k) - Vd));</span><br><span class="line"><span class="comment">% 查表确定最优系统输入位置</span></span><br><span class="line">acc_index = <span class="built_in">sub2ind</span>(<span class="built_in">size</span>(Input_acc), N_h+<span class="number">2</span>-h_plot_index, v_plot_index);</span><br><span class="line"><span class="comment">% 将最优系统输入存入表格</span></span><br><span class="line">acc_plot (k) = Input_acc(acc_index);</span><br><span class="line"><span class="comment">% 计算无人机速度</span></span><br><span class="line">v_plot (k + <span class="number">1</span>) = <span class="built_in">sqrt</span>((<span class="number">2</span> * (h_max - h_min)/N_h * acc_plot(k))+ v_plot (k)^<span class="number">2</span>); <span class="comment">% Calculate speed and height</span></span><br><span class="line"><span class="comment">% 计算无人机高度</span></span><br><span class="line">h_plot (k + <span class="number">1</span>) = h_plot(k) + (h_max - h_min)/N_h;</span><br><span class="line"><span class="comment">% 计算系统相应时刻</span></span><br><span class="line">t_plot (k + <span class="number">1</span>) = t_plot (k)+<span class="number">2</span>*(h_plot (k + <span class="number">1</span>) - h_plot(k))/(v_plot (k + <span class="number">1</span>) + v_plot (k));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%绘制视图%%</span></span><br><span class="line"><span class="comment">% 绘制速度vs.高度视图</span></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(v_plot,h_plot,<span class="string">&#x27;--o&#x27;</span>),grid on;</span><br><span class="line">ylabel(<span class="string">&#x27;h(m)&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;v(m/s)&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 绘制加速度vs.高度视图</span></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">plot</span>(acc_plot,h_plot,<span class="string">&#x27;--o&#x27;</span>),grid on;</span><br><span class="line">ylabel(<span class="string">&#x27;h(m)&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;a(m/s^2)&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 绘制速度vs.时间视图</span></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">plot</span>(t_plot,v_plot,<span class="string">&#x27;--o&#x27;</span>),grid on;</span><br><span class="line">ylabel(<span class="string">&#x27;v(m/s)&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;t(s)&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 绘制高度vs.时间视图</span></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line"><span class="built_in">plot</span>(t_plot,h_plot,<span class="string">&#x27;--o&#x27;</span>),grid on;</span><br><span class="line">ylabel(<span class="string">&#x27;h(m)&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;t&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 绘制加速度vs.时间视图</span></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line"><span class="built_in">plot</span>(t_plot,acc_plot,<span class="string">&#x27;--o&#x27;</span>),grid on;</span><br><span class="line">ylabel(<span class="string">&#x27;a(m/s^2)&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;t&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">对于《控制之美2》中动态规划章节的学习记录</summary>
    
    
    
    <category term="自动化" scheme="https://striver98.github.io/categories/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    
    <category term="最优控制" scheme="https://striver98.github.io/tags/%E6%9C%80%E4%BC%98%E6%8E%A7%E5%88%B6/"/>
    
    <category term="动态规划" scheme="https://striver98.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
</feed>
