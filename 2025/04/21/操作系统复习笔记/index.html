<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/universe.png">
  <link rel="icon" href="/img/universe.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Wang Zhixuan">
  <meta name="keywords" content="">
  
    <meta name="description" content="计算机双学位操作系统期末考试复习（终于要结束了">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统复习笔记">
<meta property="og:url" content="https://striver98.github.io/2025/04/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="午夜飞行">
<meta property="og:description" content="计算机双学位操作系统期末考试复习（终于要结束了">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blogwzx.oss-cn-beijing.aliyuncs.com/image-20250429133519023.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Striver98/Pictures/master/img/image-20250423163852296.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Striver98/Pictures/master/img/image-20250425143041731.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Striver98/Pictures/master/img/image-20250425143135437.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Striver98/Pictures/master/img/image-20250425143315998.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Striver98/Pictures/master/img/image-20250425143503151.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Striver98/Pictures/master/img/image-20250425143612961.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Striver98/Pictures/master/img/image-20250425144343231.png">
<meta property="og:image" content="https://blogwzx.oss-cn-beijing.aliyuncs.com/image-20250504170330412.png">
<meta property="og:image" content="https://blogwzx.oss-cn-beijing.aliyuncs.com/image-20250504204325209.png">
<meta property="og:image" content="https://blogwzx.oss-cn-beijing.aliyuncs.com/image-20250504204348504.png">
<meta property="og:image" content="https://blogwzx.oss-cn-beijing.aliyuncs.com/image-20250504204609657.png">
<meta property="article:published_time" content="2025-04-21T05:49:07.000Z">
<meta property="article:modified_time" content="2025-05-04T12:46:24.101Z">
<meta property="article:author" content="Wang Zhixuan">
<meta property="article:tag" content="复习">
<meta property="article:tag" content="计算机科学与技术专业">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://blogwzx.oss-cn-beijing.aliyuncs.com/image-20250429133519023.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>操作系统复习笔记 - 午夜飞行</title>

  <link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css">



  <link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css">

  <link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css">

  <link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css">



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link rel="stylesheet" href="/css/main.css">


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css">
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css">
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"striver98.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":["home"]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":"lvc5jMNgiDCshZ3sR3KkiNjR-gzGzoHsz","app_key":"yBvnSteGkTHVkCJDH80pXa1d","server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>
  

  

  

  

  

  
    
  



  
<!-- hexo injector head_end start --><style>
body hanla:after {
    content: ' ';
    display: inline;
    font-family: inherit;
    font-size: 0.45em;
}

html code hanla,
html pre hanla,
html kbd hanla,
html samp hanla,
html ruby hanla,
html .tag-list-item hanla {
    display: none;
}

html ol > hanla,
html ul > hanla {
    display: none;
}
</style><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/atom.xml" title="午夜飞行" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>午夜飞行</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax="true" style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">操作系统复习笔记</span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        Wang Zhixuan
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-04-21 13:49" pubdate="">
          2025<hanla></hanla>年<hanla></hanla>4<hanla></hanla>月<hanla></hanla>21<hanla></hanla>日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          23k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          193 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        

      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">操作系统复习笔记</h1>
            
            
              <div class="markdown-body">
                
                <p><img src="https://blogwzx.oss-cn-beijing.aliyuncs.com/image-20250429133519023.png" srcset="/img/loading.gif" lazyload></p>
<h1 id="第1章-操作系统基础知识">第<hanla></hanla>1<hanla></hanla>章 操作系统基础知识</h1>
<h2 id="练习题">练习题</h2>
<h3 id="请简述计算机从开机到操作系统完全启动的基本过程"><strong>请简述计算机从开机到操作系统完全启动的基本过程？</strong></h3>
<p>OS<hanla></hanla>的引导过程（滚雪球方式）：</p>
<ol type="1">
<li>初始引导
<ul>
<li>系统加电</li>
<li>执行初始引导程序，对系统硬件和配置进行自检，保证系统没有硬件错误</li>
<li>从硬盘中读入操作系统引导程序，并将控制权交给该程序模块</li>
</ul></li>
<li>引导程序执行：将操作系统核心文件读入内存，并将控制交给核心的初始化程序。</li>
<li>内核初始化，初始化系统数据结构及参数
<ul>
<li>系统加电建立进程有关的数据结构 ；</li>
<li>获得自由存储空间的容量，建立存储管理的数据结构 ；</li>
<li>建立系统设备和文件系统的数据结构 ；</li>
<li>初始化时钟。</li>
</ul></li>
<li>系统初始化
<ul>
<li>完善<hanla></hanla>OS<hanla></hanla>的操作环境，装载命令处理程序 (或图形用户界面)，并初始化；</li>
<li>在多用户系统中，为每个终端建立命令解释进程，使系统处于命令接收状态。</li>
</ul></li>
</ol>
<p>OS<hanla></hanla>的启动流程：</p>
<ol type="1">
<li><p>引导加载程序加载<hanla></hanla>OS<hanla></hanla>内核到内存中。</p></li>
<li><p>内核初始化：OS<hanla></hanla>内核进行一系列的初始化操作，如硬件设备检查，加载驱动，内存管理等。</p></li>
<li><p>内核启动<hanla></hanla>init<hanla></hanla>进程：内核初始化完成后，会启动<hanla></hanla>init<hanla></hanla>进程（在<hanla></hanla>Linux<hanla></hanla>中）或<hanla></hanla>systemd<hanla></hanla>进程，该进程是所有其他用户进程的父进程。</p></li>
<li><p>用户空间程序启动：init<hanla></hanla>进程根据系统的配置，启动一系列的用户空间程序，如<hanla></hanla>Shell，图形界面等。</p></li>
</ol>
<h3 id="什么是引导扇区boot-sector它在操作系统的启动过程中起什么作用"><strong>什么是引导扇区（Boot Sector）？它在操作系统的启动过程中起什么作用？</strong></h3>
<p><strong>引导扇区（Boot Sector）</strong> 是计算机存储设备（如硬盘、U<hanla></hanla>盘等）上用于启动操作系统的关键数据区域，通常占据设备的第一个物理扇区（512<hanla></hanla>字节）。它在操作系统的启动过程中扮演<hanla></hanla>“启动链”<hanla></hanla>的第一环角色，负责将控制权从 BIOS/UEFI 传递给更复杂的引导加载程序（Boot Loader）。</p>
<h3 id="请描述一个程序从点击图标到完全运行的典型执行流程"><strong>请描述一个程序从点击图标到完全运行的典型执行流程</strong>？</h3>
<ol type="1">
<li><p><strong>加载：</strong> 当启动一个程序时，由<hanla></hanla>OS<hanla></hanla>的加载器将该程序的可执行文件加载到内存中。</p></li>
<li><p><strong>运行：</strong> OS<hanla></hanla>创建一个新的进程，并将<hanla></hanla>CPU<hanla></hanla>的控制权交给该进程。该新进程开始执行加载到内存中的程序代码。</p></li>
<li><p><strong>系统调用：</strong> 当程序需要进行一些特权操作（如读写文件，发送网络数据等）时，它将发起系统调用。</p></li>
<li><p><strong>中断和信号：</strong> 程序的执行可能会被中断和信号打断。中断通常是由硬件事件触发的，如<hanla></hanla>I/O<hanla></hanla>操作的完成，定时器的超时等。信号则是一种软件中断，可以由其他进程或者内核发送。</p></li>
<li><p><strong>退出：</strong> 当程序执行完成或者由于某种原因需要停止时，它将执行退出操作，包括释放资源，关闭打开的文件，通知父进程等。</p></li>
</ol>
<h2 id="选择题">选择题</h2>
<p>在脱机批处理方式中，有一台负责与外部设备交换信息的计算机，一般称之为<hanla></hanla>_____。</p>
<p>A．终端处理机 <strong>B．外围处理机</strong></p>
<p>C．客户机 D．服务处理机</p>
<p>在计算机系统中，操作系统是<hanla></hanla>_____。</p>
<p>A. 一般应用软件 <strong>B. 核心系统软件</strong></p>
<p>C. 用户应用软件 D. 硬件</p>
<p>实时操作系统必须在<hanla></hanla>_____<hanla></hanla>内处理来自外部的事件。</p>
<p>A.<hanla></hanla>时间片 B.<hanla></hanla>周转时间</p>
<p><strong>C.<hanla></hanla>被控制对象规定时间</strong> D.<hanla></hanla>一个机器周期</p>
<p>在设计实时操作系统时，不重点考虑的是<hanla></hanla>______。</p>
<p>A．及时响应，快速处理 B．有高安全性</p>
<p><strong>C．提高系统资源的利用率</strong> D．有高可靠性</p>
<p>下述关于并发性的叙述中正确的是<hanla></hanla>_____。</p>
<p>A.<hanla></hanla>并发性是指若干事件在不同时间间隔内发生</p>
<p><strong>B.<hanla></hanla>并发性是指若干事件在同一时间间隔内发生</strong></p>
<p>C.<hanla></hanla>并发性是指若干事件在不同时刻发生</p>
<p>D.<hanla></hanla>并发性是指若干事件在同一时刻发生</p>
<p>分时系统追求的目标是<hanla></hanla>_____。</p>
<p><strong>A.<hanla></hanla>快速响应用户</strong> B.<hanla></hanla>充分利用<hanla></hanla>I/O<hanla></hanla>设备</p>
<p>C.<hanla></hanla>充分利用内存 D.<hanla></hanla>提供系统吞吐率</p>
<p>一个多道批处理系统，提高了计算机系统的资源利用率，同时<hanla></hanla>_____。</p>
<p>A. 减少各个作业的执行时间</p>
<p><strong>B. 增加了单位时间内作业的吞吐量</strong></p>
<p>C. 减少了部分作业的执行时间</p>
<p>D. 减少单位时间内作业的吞吐量</p>
<p>批处理系统的主要缺点是<hanla></hanla>_____。</p>
<p><strong>A. 无交互能力</strong> B. 系统吞吐量小</p>
<p>C. 资源利用率低 D. CPU<hanla></hanla>利用率不高</p>
<p>从用户的观点看，操作系统是<hanla></hanla>_____。</p>
<p>A.<hanla></hanla>合理地组织计算机工作流程的软件</p>
<p>B. 由若干层次的程序按一定的结构组成的有机体</p>
<p>C. 控制和管理计算机资源的软件</p>
<p><strong>D.<hanla></hanla>用户与计算机之间的接口</strong></p>
<p>所谓<hanla></hanla>_____<hanla></hanla>是指将一个以上的作业放入内存，并且同时处于运行状态，这些作业共享处理机的时间和外围设备等资源。</p>
<p><strong>A.<hanla></hanla>多道程序设计</strong> B.<hanla></hanla>多重处理</p>
<p>C.<hanla></hanla>共行执行 D.<hanla></hanla>实时处理</p>
<p>操作系统中最基本的两个特征是<hanla></hanla>_____。</p>
<p>A. 虚拟和不确定 B.<hanla></hanla>共享和虚拟</p>
<p><strong>C. 并发和共享</strong> D.<hanla></hanla>并发和不确定</p>
<h1 id="第2章-操作系统的运行环境和运行机制">第<hanla></hanla>2<hanla></hanla>章 操作系统的运行环境和运行机制</h1>
<h2 id="练习题-1">练习题</h2>
<h3 id="从应用程序的视角来看异常和中断的区别是什么"><strong>从应用程序的视角来看，异常和中断的区别是什么？</strong></h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><strong>特征</strong></th>
<th style="text-align: center;"><strong>异常</strong></th>
<th style="text-align: center;"><strong>中断</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>触发源</strong></td>
<td style="text-align: center;">程序自身</td>
<td style="text-align: center;">外部硬件或定时器</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>同步<hanla></hanla>/<hanla></hanla>异步</strong></td>
<td style="text-align: center;">同步（由指令触发）</td>
<td style="text-align: center;">异步（随机发生）</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>应用程序感知</strong></td>
<td style="text-align: center;">直接感知，可能导致崩溃或信号处理</td>
<td style="text-align: center;">间接感知（如通过系统调用返回结果）</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>处理方式</strong></td>
<td style="text-align: center;">需显式处理（如捕获异常）</td>
<td style="text-align: center;">由操作系统透明处理</td>
</tr>
</tbody>
</table>
<p>从应用程序的角度来看，<strong>异常是程序自身执行过程中的<hanla></hanla>“事故”</strong>，需要主动处理或修复；<strong>中断是外部事件的<hanla></hanla>“通知”</strong>，由操作系统代为处理，对程序透明。</p>
<p><strong>在发生<hanla></hanla>CPU<hanla></hanla>的特权级切换时，CPU<hanla></hanla>会自动保存当前的执行状态，包括程序计器<hanla></hanla>(PC)、栈指针<hanla></hanla>(Stack Pointer, SP)<hanla></hanla>等。请分析：如果不保存<hanla></hanla>PC<hanla></hanla>和<hanla></hanla>SP，会出现什么问题？</strong></p>
<ol type="1">
<li><strong>无法返回原执行流</strong>：PC 记录了下一条要执行的指令地址。如果切换特权级时未保存 PC，<strong>CPU 将无法知道中断<hanla></hanla>/<hanla></hanla>异常处理完成后应该返回到哪里继续执行</strong>。程序会跳转到错误的地址，导致执行流程混乱（例如执行随机指令、死循环或崩溃）。</li>
<li><strong>栈数据破坏与内存安全风险</strong>：SP 指向当前栈的顶部，保存了函数的返回地址、局部变量和寄存器状态。若未保存 SP，<strong>切换特权级时会使用错误的栈空间</strong>。</li>
<li><strong>特权级隔离失效</strong>：用户程序可能通过未隔离的 SP 或 PC 篡改内核栈或代码，引发安全漏洞（如提权攻击）。内核操作可能因用户态数据干扰而崩溃。</li>
<li><strong>多任务调度失效</strong>：在多任务系统中，进程切换依赖保存的 PC 和 SP 以恢复执行现场。若未保存 PC 和 SP，进程切换后无法恢复原执行状态，导致多任务调度完全失效，系统只能运行单一任务。</li>
</ol>
<h3 id="系统调用和库函数或api之间是什么关系"><strong>系统调用和库函数或<hanla></hanla>API<hanla></hanla>之间是什么关系？</strong></h3>
<p>系统调用、库函数和<hanla></hanla>API<hanla></hanla>之间的关系可以理解为<strong>不同层次的接口封装</strong>，三者协作实现用户程序与操作系统之间的交互。系统调用是<strong>操作系统内核提供的底层接口</strong>，允许用户程序（运行在用户态）请求内核（运行在内核态）执行特权操作，例如文件读写、进程创建、网络通信等。库函数是<strong>封装在用户态库中的函数</strong>，例如<hanla></hanla>C<hanla></hanla>标准库（<code>libc</code>）、数学库（<code>libm</code>）等。它们可能直接执行用户态操作，也可能间接调用系统调用。API<hanla></hanla>是<strong>一组预定义的接口规范</strong>，用于定义程序与外部系统（如操作系统、库、服务）的交互方式。</p>
<p><strong>层级结构</strong>：</p>
<figure class="highlight asciidoc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+-----------------+</span><br><span class="hljs-section">|  应用程序代码    | → 调用库函数或<hanla></hanla>API</span><br><span class="hljs-section">+-----------------+</span><br><span class="hljs-section">        ↓</span><br><span class="hljs-section">+-----------------+</span><br><span class="hljs-section">| 库函数<hanla></hanla>/API       | → 可能封装系统调用<hanla></hanla></span><br><span class="hljs-section">+-----------------+</span><br><span class="hljs-section">        ↓</span><br><span class="hljs-section">+-----------------+</span><br><span class="hljs-section">| 系统调用         | → 进入内核执行特权操作<hanla></hanla></span><br><span class="hljs-section">+-----------------+</span><br></code></pre></td></tr></tbody></table></figure>
<p><strong>示例对比</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><strong>操作</strong></th>
<th style="text-align: center;"><strong>系统调用</strong></th>
<th style="text-align: center;"><strong>库函数<hanla></hanla>/API</strong></th>
<th style="text-align: center;"><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">输出字符串</td>
<td style="text-align: center;"><code>write()</code></td>
<td style="text-align: center;"><code>printf()</code></td>
<td style="text-align: center;"><code>printf()</code><hanla></hanla>封装了 <code>write()</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">创建进程</td>
<td style="text-align: center;"><code>fork()</code></td>
<td style="text-align: center;"><code>pthread_create()</code></td>
<td style="text-align: center;">线程库可能调用 <code>clone()</code>（系统调用）</td>
</tr>
<tr class="odd">
<td style="text-align: center;">获取时间</td>
<td style="text-align: center;"><code>gettimeofday()</code></td>
<td style="text-align: center;"><code>time()</code>（C<hanla></hanla>标准库）</td>
<td style="text-align: center;"><code>time()</code><hanla></hanla>可能直接调用系统调用</td>
</tr>
<tr class="even">
<td style="text-align: center;">数学运算</td>
<td style="text-align: center;">无</td>
<td style="text-align: center;"><code>sqrt()</code>（数学库）</td>
<td style="text-align: center;">纯用户态计算，无需内核交互</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>系统调用</strong>是操作系统的底层入口，需特权级切换。</li>
<li><strong>库函数<hanla></hanla>/API</strong><hanla></hanla>是更高层次的封装，可能间接调用系统调用，也可能独立运行于用户态。</li>
<li><strong>关系</strong>：API<hanla></hanla>和库函数是对系统调用的抽象和扩展，目的是简化开发、增强功能、提高可移植性。</li>
</ul>
<h3 id="操作系统提供的系统调用有哪几种参数传递的方法"><strong>操作系统提供的系统调用有哪几种参数传递的方法</strong>？</h3>
<ol type="1">
<li>寄存器传递：将参数直接存放在<hanla></hanla><strong>CPU<hanla></hanla>寄存器</strong>中，系统调用处理程序从寄存器中读取参数。</li>
<li>内存块传递：将参数存储在<strong>用户空间的内存缓冲区</strong>中，通过寄存器传递缓冲区的<strong>地址和长度</strong>，内核通过该地址读取数据。</li>
<li>结构体指针传递：将多个参数打包为<strong>结构体</strong>，通过寄存器传递结构体的<strong>指针</strong>，内核解析结构体内容。</li>
<li>堆栈传递：将参数压入<strong>用户态堆栈</strong>，内核通过栈指针读取参数。</li>
</ol>
<h3 id="请解释说明系统调用机制涉及的概念访管指令系统调用号参数传递系统调用表系统调用实现函数"><strong>请解释说明系统调用机制涉及的概念：访管指令、系统调用号、参数传递、系统调用表、系统调用实现函数。</strong></h3>
<ol type="1">
<li>访管指令：访管指令是<strong>用户态程序主动触发内核态执行的<hanla></hanla>CPU<hanla></hanla>指令</strong>，用于请求操作系统服务。它引发一个软中断（或异常），使<hanla></hanla>CPU<hanla></hanla>切换到特权模式（内核态）。</li>
<li>系统调用好：每个系统调用在内核中对应<strong>唯一的数字编号</strong>，用于标识请求的服务类型。</li>
<li>参数传递：用户程序向内核传递系统调用所需的<strong>输入参数</strong>（如文件路径、缓冲区地址等）。</li>
<li>系统调用表：内核中维护的<strong>函数指针数组</strong>，每个条目对应一个系统调用的实现函数。</li>
<li>系统调用实现函数：内核中实际执行系统调用操作的<strong>函数</strong>，完成用户请求的服务。</li>
</ol>
<h2 id="选择题-1">选择题</h2>
<p>操作系统提供给编程人员的接口是<hanla></hanla>_____。</p>
<p><strong>A.<hanla></hanla>系统调用</strong> B.<hanla></hanla>子程序</p>
<p>C.<hanla></hanla>库函数 D.<hanla></hanla>高级语言</p>
<h1 id="第3章-进程线程模型">第<hanla></hanla>3<hanla></hanla>章 进程线程模型</h1>
<h2 id="练习题-2">练习题</h2>
<h3 id="当使用fork操作创建新进程时父进程和子进程之间会共享以下哪种状态"><strong>当使用<hanla></hanla>fork()<hanla></hanla>操作创建新进程时，父进程和子进程之间会共享以下哪种状态？</strong></h3>
<p>1.<hanla></hanla>堆栈 2.<hanla></hanla>堆 <strong>3.<hanla></hanla>共享内存段</strong></p>
<h3 id="内核在进程间执行上下文切换时采取的主要操作步骤"><strong>内核在进程间执行上下文切换时采取的主要操作步骤？</strong></h3>
<ol type="1">
<li><p>触发切换 • 由中断<hanla></hanla>/<hanla></hanla>异常（如时间片耗尽、I/O<hanla></hanla>请求）或主动系统调用（如<hanla></hanla>sleep()）引发</p></li>
<li><p>保存当前上下文 • 将当前进程的<hanla></hanla>CPU<hanla></hanla>状态存入其进程控制块<hanla></hanla>(PCB)：</p>
<p>✓ 所有寄存器（通用寄存器、程序计数器<hanla></hanla>PC、栈指针<hanla></hanla>SP） ✓ 内存管理信息（页表基址寄存器） ✓ 浮点寄存器状态 ✓ 特殊功能寄存器</p></li>
<li><p>切换至内核态 • 提升<hanla></hanla>CPU<hanla></hanla>特权级别到内核模式，使用内核栈进行后续操作</p></li>
<li><p>执行调度程序 • 通过调度算法选择下一个要运行的进程</p></li>
<li><p>更新内存管理单元 • 切换新进程的地址空间（页表基址寄存器更新）</p>
<p>• 必要时刷新<hanla></hanla>TLB（Translation Lookaside Buffer）</p></li>
<li><p>恢复新进程上下文 • 从新进程的<hanla></hanla>PCB<hanla></hanla>加载保存的寄存器状态</p>
<p>• 恢复程序计数器、栈指针等关键寄存器</p></li>
<li><p>切换用户空间 • 降低<hanla></hanla>CPU<hanla></hanla>特权级别到用户模式</p>
<p>• 开始执行新进程的代码</p></li>
</ol>
<h3 id="用户级线程与内核级线程的两个主要区别及其适用场景"><strong>用户级线程与内核级线程的两个主要区别及其适用场景？</strong></h3>
<p><strong>区别 1：管理主体与内核感知</strong></p>
<ul>
<li><strong>用户级线程</strong> ✓ 由用户空间的线程库（如 POSIX Pthreads）管理 ✓ 内核无法感知线程存在，仅看到单进程</li>
<li><strong>内核级线程</strong> ✓ 由操作系统内核直接管理 ✓ 每个线程在内核有独立的数据结构（如 Linux 的 task_struct）</li>
</ul>
<p><strong>区别 2：阻塞与并行性</strong></p>
<ul>
<li><strong>用户级线程</strong> ✓ 单个线程阻塞（如 I/O 操作）会导致整个进程阻塞 ✓ 无法利用多核 CPU 的并行性（所有线程绑定到单一内核线程）</li>
<li><strong>内核级线程</strong> ✓ 单个线程阻塞不影响其他线程执行 ✓ 支持多核并行调度（不同线程可分配到不同 CPU 核心）</li>
</ul>
<hr>
<p><strong>适用场景对比</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><strong>用户级线程更优的场景</strong></th>
<th style="text-align: center;"><strong>内核级线程更优的场景</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">需要极速线程切换（无内核态切换开销）</td>
<td style="text-align: center;">需要多核并行计算（如科学计算、视频渲染）</td>
</tr>
<tr class="even">
<td style="text-align: center;">大规模轻量级线程（如百万级连接处理）</td>
<td style="text-align: center;">涉及频繁阻塞操作（如文件<hanla></hanla>I/O<hanla></hanla>密集型任务）</td>
</tr>
<tr class="odd">
<td style="text-align: center;">跨平台移植性要求高（不依赖<hanla></hanla>OS<hanla></hanla>支持）</td>
<td style="text-align: center;">需要实时响应调度（如嵌入式系统控制）</td>
</tr>
</tbody>
</table>
<h2 id="选择题-2">选择题</h2>
<p>对进程的管理和控制使用<hanla></hanla>_____。</p>
<p>A. 指令 B. 信号量</p>
<p><strong>C. 原语</strong> D. 信箱</p>
<p>分配到必要的资源并获得处理机时的进程状态是<hanla></hanla>_____。</p>
<p>A. 就绪状态 B.<hanla></hanla>撤消状态</p>
<p><strong>C. 执行状态</strong> D.<hanla></hanla>阻塞状态</p>
<p>下列进程状态变化中，_____<hanla></hanla>变化是不可能发生的。</p>
<p>A.<hanla></hanla>等待→就绪 <strong>B.<hanla></hanla>等待→运行</strong></p>
<p>C.<hanla></hanla>运行→等待 D.<hanla></hanla>运行→就绪</p>
<p>当<hanla></hanla>_____<hanla></hanla>时，进程从执行状态转变为就绪状态。</p>
<p>A.<hanla></hanla>等待的事件发生 <strong>B.<hanla></hanla>时间片到</strong></p>
<p>C. 等待某一事件 D.<hanla></hanla>进程被调度程序选中</p>
<p>下面对进程的描述中，错误的是<hanla></hanla>_____。</p>
<p>A.<hanla></hanla>进程是有生命期的 B. 进程执行需要处理机</p>
<p><strong>C.<hanla></hanla>进程是指令的集合</strong> D.<hanla></hanla>进程是动态的概念</p>
<p>如果系统中有<hanla></hanla>n<hanla></hanla>个进程，则就绪队列中进程的个数最多为<hanla></hanla>_____。</p>
<p>A. n B. 1 <strong>C. n-1</strong> D. n+1</p>
<p>操作系统通过<hanla></hanla>_____<hanla></hanla>对进程进行管理。</p>
<p>A. JCB <strong>B. PCB</strong></p>
<p>C. DCT D. CHCT</p>
<p>下面所述步骤中，_____<hanla></hanla>不是创建进程所必需的。</p>
<p>A.<hanla></hanla>建立一个进程控制块</p>
<p>B.<hanla></hanla>为进程分配内存</p>
<p>C. 将进程控制块链入就绪队列</p>
<p><strong>D.<hanla></hanla>由调度程序为进程分配<hanla></hanla>CPU</strong></p>
<p>下述哪一个选项，体现了原语的主要特点<hanla></hanla>_____。</p>
<p>A. 并发性 B. 异步性</p>
<p><strong>C.<hanla></hanla>不可分割性</strong> D.<hanla></hanla>共享性</p>
<p>下面对父进程和子进程的叙述不正确的是<hanla></hanla>_____。</p>
<p>A. 撤消父进程之时，可以同时撤消其子进程</p>
<p>B. 父进程和子进程之间可以并发</p>
<p>C. 父进程可以等待所有子进程结束后再执行</p>
<p><strong>D.<hanla></hanla>父进程创建了子进程，因此父进程执行完了子进程才能运行</strong></p>
<p>下列几种关于进程的叙述中，最不符合操作系统对进程理解的是<hanla></hanla>_____。</p>
<p><strong>A．进程是在多程序并行环境中的完整的程序</strong></p>
<p>B．进程可以由程序，数据和进程控制块描述</p>
<p>C．线程<hanla></hanla>(Thread)<hanla></hanla>是一种特殊的进程</p>
<p>D．进程是程序在一个数据集合上运行的过程，是系统进行资源分配和调度的一个独立单位</p>
<p>当一个进程处于<hanla></hanla>_____<hanla></hanla>的状态时，称其为等待状态</p>
<p>A．它正等待调度</p>
<p><strong>B．它正等着协作进程的一个消息</strong></p>
<p>C．它正等分给它一个时间片</p>
<p>D．它正等进入内存</p>
<p>进程从执行状态到阻塞状态可能是由于<hanla></hanla>_____ 。</p>
<p>A．进程调度程序的调度</p>
<p>B．现运行进程的时间片用完</p>
<p><strong>C．现运行进程执行了<hanla></hanla>P<hanla></hanla>操作</strong></p>
<p>D．现运行进程执行了<hanla></hanla>V<hanla></hanla>操作</p>
<p>一个进程被唤醒意味着<hanla></hanla>_____ 。</p>
<p>A．该进程重新占有了<hanla></hanla>CPU</p>
<p><strong>B．进程状态变为就绪</strong></p>
<p>C．它的优先权变为最大</p>
<p>D．其<hanla></hanla>PCB<hanla></hanla>移至就绪队列的队首</p>
<p>一个进程基本状态可以从其他两种基本状态转变过来 ，这个基本状态是<hanla></hanla>_____。</p>
<p>A．执行状态 B．阻塞状态</p>
<p><strong>C．就绪状态</strong> D．撤销状态</p>
<p>设系统中有<hanla></hanla>n（n&gt;2）个进程，且当前不在执行进程调度程序，试考虑下述<hanla></hanla>4<hanla></hanla>种情况：</p>
<ol type="1">
<li><p>有<hanla></hanla>1<hanla></hanla>个运行进程，n-1<hanla></hanla>个就绪进程，没有进程处于等待状态。</p></li>
<li><p>有<hanla></hanla>1<hanla></hanla>个运行进程，没有就绪进程，n-1<hanla></hanla>进程处于等待状态。</p></li>
<li><p>有<hanla></hanla>1<hanla></hanla>个运行进程，有<hanla></hanla>1<hanla></hanla>个就绪进程，n-2<hanla></hanla>进程处于等待状态。</p></li>
<li><p><strong>没有运行进程，有<hanla></hanla>2<hanla></hanla>个就绪进程，n<hanla></hanla>个进程处于等待状态</strong></p></li>
</ol>
<p>上述情况中，不可能发生的情况是<hanla></hanla>_____。</p>
<p>下面关于进程的叙述中，不正确的有 _____ 条。2</p>
<p><strong>① 进程申请<hanla></hanla>CPU<hanla></hanla>得不到满足时，其状态变为等待状态。</strong></p>
<p>② 在单<hanla></hanla>CPU<hanla></hanla>系统中，任一时刻都有一个进程处于运行状态。</p>
<p><strong>③ 优先级是进行进程调度的重要依据，一旦确定不能改变。</strong></p>
<p>④ 进程获得处理机而运行是通过调度而实现的。</p>
<p>下列选项中，导致创建新进程的操作是 。</p>
<p>Ⅰ 用户登录成功 Ⅱ 设备分配</p>
<p>Ⅲ 启动程序执行</p>
<p>A.<hanla></hanla>仅Ⅰ和Ⅱ B.<hanla></hanla>仅Ⅱ和Ⅲ</p>
<p><strong>C.<hanla></hanla>仅Ⅰ和Ⅲ</strong> D.Ⅰ、Ⅱ、Ⅲ</p>
<p>下列选项中，在用户态执行的是<hanla></hanla>____。</p>
<p><strong>A、命令解释程序</strong> B、缺页处理程序</p>
<p>C、进程调度程序 D、时钟中断处理程序</p>
<p>下列选项中，不可能在用户态发生的事件是（）。</p>
<p>A．系统调用 B. 外部中断</p>
<p><strong>C. 进程切换</strong> D. 缺页</p>
<h1 id="第4章-进程线程调度">第<hanla></hanla>4<hanla></hanla>章 进程线程调度</h1>
<h2 id="练习题-3">练习题</h2>
<h3 id="解释抢占式调度preemptive-scheduling和非抢占式调度nonpreemptive-scheduling的区别"><strong>解释抢占式调度（preemptive scheduling）和非抢占式调度（nonpreemptive scheduling）的区别。</strong></h3>
<p><strong>1. 抢占式调度（Preemptive Scheduling）</strong></p>
<ul>
<li><strong>定义</strong>：操作系统可以在<strong>任意时刻</strong>中断当前运行的进程，将<hanla></hanla>CPU<hanla></hanla>分配给其他更高优先级或更紧急的进程。</li>
<li>特点：
<ul>
<li>进程<strong>不需要主动释放<hanla></hanla>CPU</strong>，调度程序强制剥夺其执行权。</li>
<li>适用于<strong>分时系统</strong>、实时系统等需要快速响应的场景。</li>
</ul></li>
<li>触发条件：
<ul>
<li>时间片用完（如<hanla></hanla>RR<hanla></hanla>轮转调度）。</li>
<li>更高优先级进程就绪（如优先级调度）。</li>
<li>中断或系统调用导致内核态切换时可能触发调度。</li>
</ul></li>
<li><strong>优点</strong>：公平性高、响应快，避免单一进程长期独占<hanla></hanla>CPU。</li>
<li><strong>缺点</strong>：上下文切换开销较大。</li>
</ul>
<p><strong>2. 非抢占式调度（Nonpreemptive Scheduling）</strong></p>
<ul>
<li><strong>定义</strong>：进程<strong>主动释放<hanla></hanla>CPU</strong><hanla></hanla>后才会发生调度（如等待<hanla></hanla>I/O、执行完毕或主动调用<hanla></hanla><code>yield()</code>）。</li>
<li>特点：
<ul>
<li>进程一旦获得<hanla></hanla>CPU，除非自身阻塞或终止，否则不会被强制中断。</li>
<li>常见于批处理系统或简单嵌入式系统。</li>
</ul></li>
<li>触发条件：
<ul>
<li>进程执行完毕。</li>
<li>进程主动阻塞（如等待资源）。</li>
<li>进程调用<hanla></hanla><code>exit()</code><hanla></hanla>终止。</li>
</ul></li>
<li><strong>优点</strong>：上下文切换少，系统开销低。</li>
<li><strong>缺点</strong>：可能导致长进程垄断<hanla></hanla>CPU，降低交互性。</li>
</ul>
<h4 id="关键区别总结"><strong>关键区别总结</strong></h4>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><strong>对比维度</strong></th>
<th style="text-align: center;"><strong>抢占式调度</strong></th>
<th style="text-align: center;"><strong>非抢占式调度</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>控制权归属</strong></td>
<td style="text-align: center;">操作系统强制剥夺<hanla></hanla>CPU</td>
<td style="text-align: center;">进程主动释放<hanla></hanla>CPU</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>响应速度</strong></td>
<td style="text-align: center;">高（适合交互式系统）</td>
<td style="text-align: center;">低（适合批处理任务）</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>典型场景</strong></td>
<td style="text-align: center;">分时系统、实时<hanla></hanla>OS</td>
<td style="text-align: center;">批处理系统、简单任务调度</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>实现复杂度</strong></td>
<td style="text-align: center;">高（需处理中断、上下文保存）</td>
<td style="text-align: center;">低（仅需简单队列管理）</td>
</tr>
</tbody>
</table>
<h3 id="在rr策略的设计实现中通常会维护一个运行队列队列中的元素是对任务的引用指针每次被调度的任务会运行固定长度的时间片如果在实施rr策略的队列中加入一个功能可以在该任务的后面插入多个对同一任务的引用那么这样的设计会带来什么样的影响这样的设计使得rr策略与什么类型的调度相似"><strong>在<hanla></hanla>RR<hanla></hanla>策略的设计实现中，通常会维护一个运行队列，队列中的元素是对任务的引用（指针），每次被调度的任务会运行固定长度的时间片。如果在实施<hanla></hanla>RR<hanla></hanla>策略的队列中加入一个功能，可以在该任务的后面插入多个对同一任务的引用，那么这样的设计会带来什么样的影响？这样的设计使得<hanla></hanla>RR<hanla></hanla>策略与什么类型的调度相似？</strong></h3>
<p>在标准<hanla></hanla><strong>RR（Round-Robin，轮转调度）</strong>策略中：</p>
<ol type="1">
<li>所有就绪任务按<hanla></hanla><strong>FIFO<hanla></hanla>顺序</strong>排列在一个队列中。</li>
<li>每个任务执行<strong>固定时间片（time quantum）</strong>后，被移回队列尾部。</li>
<li>公平性：每个任务获得<strong>均等的<hanla></hanla>CPU<hanla></hanla>时间份额</strong>。</li>
</ol>
<p>若在<hanla></hanla>RR<hanla></hanla>队列中<strong>允许对同一任务插入多个引用</strong>（即同一任务在队列中出现多次），会产生以下影响：</p>
<p><strong>1）任务获得的<hanla></hanla>CPU<hanla></hanla>时间增加</strong></p>
<ul>
<li>原理：任务在队列中的引用次数越多，被调度的概率越高。
<ul>
<li>例如：任务<hanla></hanla>A<hanla></hanla>有<hanla></hanla>3<hanla></hanla>个引用，任务<hanla></hanla>B<hanla></hanla>有<hanla></hanla>1<hanla></hanla>个引用 → A<hanla></hanla>的<hanla></hanla>CPU<hanla></hanla>时间约为<hanla></hanla>B<hanla></hanla>的<hanla></hanla>3<hanla></hanla>倍。</li>
</ul></li>
<li>效果：
<ul>
<li><strong>优点</strong>：可为高优先级任务分配更多资源（类似优先级调度）。</li>
<li><strong>缺点</strong>：破坏<hanla></hanla>RR<hanla></hanla>的公平性，低引用任务可能<hanla></hanla>“饥饿”（Starvation）。</li>
</ul></li>
</ul>
<p><strong>（2）调度行为趋近于优先级调度</strong></p>
<ul>
<li><p>动态优先级模拟：通过调整任务的引用次数，间接实现优先级控制。</p>
<ul>
<li>例如：后台任务保持<hanla></hanla>1<hanla></hanla>个引用，交互式任务插入多个引用以提升响应速度。</li>
</ul></li>
<li><p>与标准<hanla></hanla>RR<hanla></hanla>的区别：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><strong>标准<hanla></hanla>RR</strong></th>
<th style="text-align: center;"><strong>多引用<hanla></hanla>RR</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">严格公平（时间片均等）</td>
<td style="text-align: center;">允许任务权重差异化</td>
</tr>
<tr class="even">
<td style="text-align: center;">无优先级</td>
<td style="text-align: center;">隐式优先级（引用数<hanla></hanla>=<hanla></hanla>权重）</td>
</tr>
</tbody>
</table></li>
</ul>
<p><strong>（3）实现复杂度提高</strong></p>
<ul>
<li>需维护引用计数，避免同一任务被重复执行（如时间片未用完时跳过冗余引用）。</li>
<li>需处理任务终止时的引用清理（防止悬垂指针）。</li>
</ul>
<p>这样的设计使得<hanla></hanla>RR<hanla></hanla>策略<strong>与多级反馈队列（MLFQ）或权重轮转（Weighted RR）调度相似</strong></p>
<ul>
<li>多级反馈队列（MLFQ）：
<ul>
<li>通过将任务分配到不同优先级的队列，实现<strong>动态优先级调整</strong>。</li>
<li>高优先级队列中的任务获得更多<hanla></hanla>CPU<hanla></hanla>时间（类似多引用任务的权重优势）。</li>
</ul></li>
<li>权重轮转（Weighted RR）：
<ul>
<li>直接为任务分配权重（如<hanla></hanla>3:1），权重高的任务获得更多时间片。</li>
<li>本例中<hanla></hanla>“引用次数”<hanla></hanla>实质是权重的隐式表达。</li>
</ul></li>
</ul>
<h3 id="什么是处理器亲和性processor-affinity它在多处理器调度中起什么作用"><strong>什么是处理器亲和性（Processor Affinity）？它在多处理器调度中起什么作用？</strong></h3>
<p><strong>处理器亲和性</strong>是指进程或线程<strong>倾向于在特定的</strong>处理器或处理器集合上运行的特性。</p>
<p>作用：由于该进程或线程之前在这些处理器上运行过，因此可能有一些数据或状态仍然缓存在那里，如果再次在这些处理器上运行，则可以利用这些缓存数据，从而提高性能。</p>
<h1 id="第5章-进程同步机制">第<hanla></hanla>5<hanla></hanla>章 进程同步机制</h1>
<h2 id="练习题-4">练习题</h2>
<h3 id="过桥问题">过桥问题</h3>
<p>赵家村和李家村靠一座独木桥连接，独木桥上一次只能供一个方向上的行人行走。</p>
<p>（1）若独木桥上一次只允许一个人行走，请用信号量实现对行人的同步。</p>
<p>（2）若不考虑独木桥的载重量，只要桥上有赵家村的人往李家村走<hanla></hanla>(或李家村的人往赵家村走)，其他同方向的人就可以连续通过。当桥上没有某一方向的行人行走时，另一方向的行人就可以走。请用信号量实现对两个方向上行人的同步。</p>
<hr>
<p><strong>（1）一次仅允许一人通行</strong> <strong>解法：互斥信号量</strong> • 信号量设计：</p>
<p>• <code>mutex</code>：初始值为<hanla></hanla>1，表示桥的互斥访问权。</p>
<p>• 伪代码：</p>
<p></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">semaphore mutex = <span class="hljs-number">1</span>; <span class="hljs-comment">// 独木桥互斥锁<hanla></hanla></span><br><br><span class="hljs-comment">// 赵家村行人（A<hanla></hanla>方向）</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">person_A</span><span class="hljs-params">()</span> {<br>    wait(mutex);    <span class="hljs-comment">// 申请桥的使用权</span><br>    cross_bridge(); <span class="hljs-comment">// 过桥</span><br>    signal(mutex);  <span class="hljs-comment">// 释放桥</span><br>}<br><br><span class="hljs-comment">// 李家村行人（B<hanla></hanla>方向）</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">person_B</span><span class="hljs-params">()</span> {<br>    wait(mutex);    <span class="hljs-comment">// 申请桥的使用权</span><br>    cross_bridge(); <span class="hljs-comment">// 过桥</span><br>    signal(mutex);  <span class="hljs-comment">// 释放桥</span><br>}<br></code></pre></td></tr></tbody></table></figure> • 说明：<p></p>
<p>• <code>wait(mutex)</code> 和 <code>signal(mutex)</code> 保证同一时间只有一人过桥。</p>
<hr>
<p><strong>（2）允许同方向连续通行，反方向需等待</strong> <strong>解法：读者-写者变种（方向优先级）</strong> • 信号量设计：</p>
<p>• <code>bridge</code>：互斥锁，初始值为<hanla></hanla>1（保护方向切换）。</p>
<p>• <code>counter_A</code> 和 <code>counter_B</code>：统计当前方向的行人数量。</p>
<p>• <code>mutex_A</code> 和 <code>mutex_B</code>：保护对应计数器的互斥锁（初始值为<hanla></hanla>1）。</p>
<p>• 伪代码：</p>
<p></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c">semaphore bridge = <span class="hljs-number">1</span>;     <span class="hljs-comment">// 方向切换锁<hanla></hanla></span><br>semaphore mutex_A = <span class="hljs-number">1</span>;    <span class="hljs-comment">// 保护赵家村计数器<hanla></hanla></span><br>semaphore mutex_B = <span class="hljs-number">1</span>;    <span class="hljs-comment">// 保护李家村计数器<hanla></hanla></span><br><span class="hljs-type">int</span> counter_A = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 赵家村方向行人计数<hanla></hanla></span><br><span class="hljs-type">int</span> counter_B = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 李家村方向行人计数<hanla></hanla></span><br><br><span class="hljs-comment">// 赵家村→李家村方向（A<hanla></hanla>方向）</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">person_A</span><span class="hljs-params">()</span> {<br>    wait(mutex_A);        <span class="hljs-comment">// 保护<hanla></hanla>counter_A</span><br>    <span class="hljs-keyword">if</span> (counter_A == <span class="hljs-number">0</span>)   <span class="hljs-comment">// 如果是第一个<hanla></hanla>A<hanla></hanla>方向行人</span><br>        wait(bridge);     <span class="hljs-comment">// 申请方向锁（禁止<hanla></hanla>B<hanla></hanla>方向）</span><br>    counter_A++;          <span class="hljs-comment">// 增加<hanla></hanla>A<hanla></hanla>方向计数</span><br>    signal(mutex_A);<br><br>    cross_bridge();       <span class="hljs-comment">// 过桥</span><br><br>    wait(mutex_A);<br>    counter_A--;          <span class="hljs-comment">// 离开桥</span><br>    <span class="hljs-keyword">if</span> (counter_A == <span class="hljs-number">0</span>)   <span class="hljs-comment">// 如果是最后一个<hanla></hanla>A<hanla></hanla>方向行人</span><br>        signal(bridge);   <span class="hljs-comment">// 释放方向锁（允许<hanla></hanla>B<hanla></hanla>方向）</span><br>    signal(mutex_A);<br>}<br><br><span class="hljs-comment">// 李家村→赵家村方向（B<hanla></hanla>方向）</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">person_B</span><span class="hljs-params">()</span> {<br>    wait(mutex_B);<br>    <span class="hljs-keyword">if</span> (counter_B == <span class="hljs-number">0</span>)<br>        wait(bridge);     <span class="hljs-comment">// 申请方向锁（禁止<hanla></hanla>A<hanla></hanla>方向）</span><br>    counter_B++;<br>    signal(mutex_B);<br><br>    cross_bridge();<br><br>    wait(mutex_B);<br>    counter_B--;<br>    <span class="hljs-keyword">if</span> (counter_B == <span class="hljs-number">0</span>)<br>        signal(bridge);   <span class="hljs-comment">// 释放方向锁</span><br>    signal(mutex_B);<br>}<br></code></pre></td></tr></tbody></table></figure> • 关键逻辑：<p></p>
<ol type="1">
<li>第一个行人获取 <code>bridge</code> 锁，锁定方向。<br>
</li>
<li>后续同方向行人直接通过（不竞争 <code>bridge</code>）。<br>
</li>
<li>最后一个行人释放 <code>bridge</code> 锁，允许反方向行人通行。<br>
• 特点：</li>
</ol>
<p>• 同方向可连续通行（类似读者-写者的<hanla></hanla>“读者优先”）。</p>
<p>• 反方向行人需等待桥上无人（<code>bridge</code> 释放）才能通行。</p>
<hr>
<h3 id="咖啡店问题">咖啡店问题</h3>
<p>在一家繁忙的咖啡店，顾客不断地排队下订单。咖啡店有多个收银员和咖啡师。为了提高效率和顾客满意度，咖啡店需要一个系统来管理订单的处理。</p>
<p>假设系统中有<hanla></hanla>N<hanla></hanla>个收银员线程负责接受顾客订单，有<hanla></hanla>M<hanla></hanla>个咖啡师线程负责制作饮品。订单需要先由收银员处理，然后由咖啡师制作。</p>
<p>请使用信号量和互斥锁来协调收银员和咖啡师之间的工作。确保订单被正确地接收和处理，并且咖啡师在有订单时才开始制作。</p>
<p>输出每个订单的接收和完成时间，以及当前队列中的订单数量。</p>
<p>提示</p>
<ul>
<li>使用一个共享队列来存储订单，使用信号量来表示队列中的订单数量。</li>
<li>使用互斥锁保护对订单队列的插入和删除操作。</li>
<li>每个收银员和咖啡师由一个线程模拟。</li>
</ul>
<p><strong>问题分析</strong> 我们需要模拟一个咖啡店的订单处理系统，其中： 1. 收银员线程（N<hanla></hanla>个）：负责接收顾客订单，并将订单加入共享队列。 2. 咖啡师线程（M<hanla></hanla>个）：从共享队列获取订单并制作饮品。 3. 共享订单队列：存储待处理的订单，需保证线程安全。 4. 同步机制： • 收银员和咖啡师需互斥访问队列（防止数据竞争）。</p>
<p>• 咖啡师需等待订单到来（避免忙等待）。</p>
<p>• 收银员需通知咖啡师有新订单。</p>
<hr>
<p><strong>同步方案设计</strong> <strong>1. 信号量与互斥锁</strong> • <code>queue_mutex</code>：互斥锁，保护共享队列的插入<hanla></hanla>/<hanla></hanla>删除操作（初始值<hanla></hanla>=1）。</p>
<p>• <code>orders_available</code>：信号量，表示队列中的订单数量（初始值<hanla></hanla>=0），咖啡师通过 <code>wait</code> 等待订单。</p>
<p>• <code>queue_space</code>：信号量（可选），限制队列最大长度（避免内存耗尽）。</p>
<p><strong>2. 共享数据结构</strong> • 订单队列：存储订单（如订单<hanla></hanla>ID、接收时间等）。</p>
<p>• 全局计数器：记录已处理的订单数量（需原子操作或加锁）。</p>
<p><strong>3. 线程行为</strong> • 收银员线程：</p>
<ol type="1">
<li><p>接收订单（模拟输入）。</p></li>
<li><p>获取 <code>queue_mutex</code>，将订单加入队列。</p></li>
<li><p>释放 <code>queue_mutex</code>，并 <code>signal(orders_available)</code>。 • 咖啡师线程：</p></li>
<li><p><code>wait(orders_available)</code> 等待订单。</p></li>
<li><p>获取 <code>queue_mutex</code>，从队列取出订单。</p></li>
<li><p>释放 <code>queue_mutex</code>，制作饮品并记录完成时间。</p></li>
</ol>
<hr>
<p><strong>代码实现（伪代码）</strong> </p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread, Semaphore, Lock<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> queue<br><br><span class="hljs-comment"># 全局变量<hanla></hanla></span><br>order_queue = queue.Queue()  <span class="hljs-comment"># 线程安全队列（实际可用<hanla></hanla>list+<hanla></hanla>锁模拟）</span><br>queue_mutex = Lock()         <span class="hljs-comment"># 保护队列操作<hanla></hanla></span><br>orders_available = Semaphore(<span class="hljs-number">0</span>)  <span class="hljs-comment"># 初始无订单<hanla></hanla></span><br>order_counter = <span class="hljs-number">0</span>            <span class="hljs-comment"># 已处理订单数（需原子操作或加锁）</span><br><br><span class="hljs-comment"># 收银员线程<hanla></hanla></span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cashier_thread</span>(<span class="hljs-params">cashier_id</span>):<br>    <span class="hljs-keyword">global</span> order_counter<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment"># 模拟接收订单</span><br>        order_time = time.time()<br>        order = {<span class="hljs-string">"id"</span>: order_counter, <span class="hljs-string">"received"</span>: order_time}<br>        order_counter += <span class="hljs-number">1</span><br><br>        <span class="hljs-comment"># 将订单加入队列</span><br>        <span class="hljs-keyword">with</span> queue_mutex:<br>            order_queue.put(order)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f"订单 <span class="hljs-subst">{order[<span class="hljs-string">'id'</span>]}</span> 接收时间: <span class="hljs-subst">{order_time:<span class="hljs-number">.2</span>f}</span>, 队列长度: <span class="hljs-subst">{order_queue.qsize()}</span>"</span>)<br><br>        <span class="hljs-comment"># 通知咖啡师有新订单</span><br>        orders_available.release()<br>        time.sleep(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 模拟处理间隔</span><br><br><span class="hljs-comment"># 咖啡师线程<hanla></hanla></span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">barista_thread</span>(<span class="hljs-params">barista_id</span>):<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment"># 等待订单</span><br>        orders_available.acquire()<br><br>        <span class="hljs-comment"># 从队列取出订单</span><br>        <span class="hljs-keyword">with</span> queue_mutex:<br>            order = order_queue.get()<br>            queue_size = order_queue.qsize()<br><br>        <span class="hljs-comment"># 模拟制作饮品</span><br>        completion_time = time.time()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"订单 <span class="hljs-subst">{order[<span class="hljs-string">'id'</span>]}</span> 完成时间: <span class="hljs-subst">{completion_time:<span class="hljs-number">.2</span>f}</span>, 制作耗时: <span class="hljs-subst">{completion_time - order[<span class="hljs-string">'received'</span>]:<span class="hljs-number">.2</span>f}</span>s, 队列剩余: <span class="hljs-subst">{queue_size}</span>"</span>)<br><br>        time.sleep(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 模拟制作时间</span><br><br><span class="hljs-comment"># 启动线程<hanla></hanla></span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):<br>    Thread(target=cashier_thread, args=(i,)).start()<br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(M):<br>    Thread(target=barista_thread, args=(j,)).start()<br></code></pre></td></tr></tbody></table></figure><p></p>
<hr>
<p><strong>关键点说明</strong> 1. 线程安全队列： • 使用 <code>queue_mutex</code> 保护队列操作（若用 <code>list</code> 需手动加锁）。</p>
<p>• Python 的 <code>queue.Queue</code> 本身是线程安全的，但为演示显式加锁。</p>
<ol start="2" type="1">
<li><p>信号量作用： • <code>orders_available</code> 确保咖啡师仅在订单到达时工作（避免忙等待）。</p></li>
<li><p>输出信息： • 订单接收时间、完成时间、队列长度，用于监控系统状态。</p></li>
<li><p>扩展性： • 可添加 <code>queue_space</code> 信号量限制队列最大长度（防止内存溢出）。</p>
<p>• 可引入优先级队列（如<hanla></hanla>VIP<hanla></hanla>订单优先处理）。</p></li>
</ol>
<hr>
<p><strong>总结</strong> • 收银员和咖啡师通过互斥锁<hanla></hanla>+<hanla></hanla>信号量协同工作。</p>
<p>• 订单队列作为缓冲区，解耦接收与制作过程。</p>
<p>• 输出信息帮助分析系统性能（如平均等待时间、队列拥堵情况）。</p>
<p>• 实际应用中，可结合线程池（<code>ThreadPoolExecutor</code>）优化资源管理。</p>
<p>​ 某银行提供一个服务窗口和<hanla></hanla>10<hanla></hanla>个供顾客等待的座位。顾客到达银行时，若有空座位，则到取号机上领取一个号，等待叫号。取号机每次仅允许一个顾客使用。当营业员空闲时，通过叫号选取一位顾客，并为其服务。顾客及营业员的活动描述如下：</p>
<p>cobegin</p>
<p>{ process 顾客</p>
<p>​ { 从取号机获取一个号码；</p>
<p>​ 等待叫号；</p>
<pre><code class="hljs"> 获得服务； }</code></pre>
<p>process 营业员</p>
<p>{ while（TRUE）</p>
<p>{ 叫号；</p>
<p>​ 为顾客服务；} }</p>
<p>}coend</p>
<p>请添加必要的信号量和<hanla></hanla>P、V（或<hanla></hanla>wait（）、signal（））操作，实现上述过程中的互斥与同步。要求写出完整的过程，说明信号量的含义并赋初值。</p>
<p>semaphore mutex=1; //<hanla></hanla>互斥使用取号机</p>
<p>semaphore empty=10; //<hanla></hanla>空座位的数量</p>
<p>semaphore full=0; //<hanla></hanla>已占座位的数量</p>
<p>semaphore service=0; //<hanla></hanla>等待叫号</p>
<p>cobegin</p>
<p>{ process 顾客<hanla></hanla>i</p>
<p>{ P(empty); P(mutex);</p>
<p>从取号机获得一个号;</p>
<p>V(mutex); V(full);</p>
<p>P(service); // 等待叫号 }</p>
<p>process 营业员</p>
<p>{ while(TRUE)</p>
<p>{ P(full);</p>
<p>​ V(empty);</p>
<p>​ V(service); //<hanla></hanla>叫号</p>
<p>​ 为顾客服务;</p>
<p>}</p>
<p>}</p>
<p>}coend</p>
<h2 id="选择题-3">选择题</h2>
<p>若信号量<hanla></hanla>S<hanla></hanla>的初值为<hanla></hanla>2，当前值为-1，则表示有<hanla></hanla>_____<hanla></hanla>等待进程。</p>
<p>A. 2<hanla></hanla>个 B. 1<hanla></hanla>个</p>
<p>C. 0<hanla></hanla>个 <strong>D. 3<hanla></hanla>个</strong></p>
<p>在操作系统中，P、V<hanla></hanla>操作是一种<hanla></hanla>_____。</p>
<p>A. 机器指令 B. 系统调用命令</p>
<p>C. 作业控制命令 <strong>D. 低级进程通信原语</strong></p>
<p>下述哪个选项不是管程的组成部分<hanla></hanla>_____。</p>
<p>A.<hanla></hanla>对局部于管程的数据结构设置初值的语句</p>
<p>B.<hanla></hanla>局部于管程的共享数据说明</p>
<p>C.<hanla></hanla>管程内对数据结构进行操作的一组过程</p>
<p><strong>D.<hanla></hanla>管程外过程调用管程内数据结构的说明</strong></p>
<p>临界区是<hanla></hanla>_____。</p>
<p>A.<hanla></hanla>一段共享数据区 <strong>B. 一段程序</strong></p>
<p>C.<hanla></hanla>一个互斥资源 D.<hanla></hanla>一个缓冲区</p>
<p>用<hanla></hanla>P、V<hanla></hanla>操作管理临界区时，信号量的初值应定义为<hanla></hanla>_____。</p>
<p><strong>A. 1</strong> B. 2</p>
<p>C. -1 D. 0</p>
<p>对于两个并发进程，设互斥信号量为<hanla></hanla>mutex,<hanla></hanla>若<hanla></hanla>mutex=0<hanla></hanla>则<hanla></hanla>_____。</p>
<p>A.<hanla></hanla>表示有一个进程进入临界区，另一个进程等待进入</p>
<p>B. 表示没有进程进入临界区</p>
<p><strong>C. 表示有一个进程进入临界区</strong></p>
<p>D. 表示有两个进程进入临界区</p>
<p>对信号量<hanla></hanla>S<hanla></hanla>执行<hanla></hanla>V<hanla></hanla>操作后，下述选项正确的是<hanla></hanla>_____。</p>
<p>A.<hanla></hanla>当<hanla></hanla>S<hanla></hanla>小于<hanla></hanla>0<hanla></hanla>时唤醒一个阻塞进程</p>
<p><strong>B.<hanla></hanla>当<hanla></hanla>S<hanla></hanla>小于等于<hanla></hanla>0<hanla></hanla>时唤醒一个阻塞进程</strong></p>
<p>C.<hanla></hanla>当<hanla></hanla>S<hanla></hanla>小于<hanla></hanla>0<hanla></hanla>时唤醒一个就绪进程</p>
<p>D.<hanla></hanla>当<hanla></hanla>S<hanla></hanla>小于等于<hanla></hanla>0<hanla></hanla>时唤醒一个就绪进程</p>
<p>对信号量<hanla></hanla>X<hanla></hanla>执行<hanla></hanla>P<hanla></hanla>操作时，若 _____ 则进程进入等待状态。</p>
<p><strong>A．X-1&lt;0</strong> B．X-1&lt;=0</p>
<p>C．X-1&gt;0 D．X-1&gt;=0</p>
<p>有若干并发进程均将共享变量<hanla></hanla>count<hanla></hanla>的值加<hanla></hanla>1<hanla></hanla>一次，那么有关<hanla></hanla>count<hanla></hanla>值说法正确的是<hanla></hanla>_____。</p>
<p>A．得到的结果肯定不正确</p>
<p>B．得到的结果肯定正确</p>
<p><strong>C．若控制这些并发进程互斥执行<hanla></hanla>count<hanla></hanla>加<hanla></hanla>1<hanla></hanla>操作，count<hanla></hanla>中的值正确</strong></p>
<p>D．A，B，C<hanla></hanla>均不对</p>
<p>下述关于管程的描述中错误的是<hanla></hanla>____ 。</p>
<p>A．管程是一种进程同步工具，解决了信号量机制 中大量同步操作分散问题</p>
<p>B．管程每次只允许一个进程进入管程</p>
<p><strong>C．管程中的<hanla></hanla>signal<hanla></hanla>操作的作用和信号量机制中的<hanla></hanla>signal<hanla></hanla>操作相同</strong></p>
<p>D．管程是被进程调用的</p>
<p>单处理机系统中，可并行的是 。</p>
<p>Ⅰ. 进程与进程 Ⅱ. 处理机与设备</p>
<p>Ⅲ. 处理机与通道 Ⅳ. 设备与设备</p>
<p>A.Ⅰ、Ⅱ和Ⅲ B.Ⅰ、Ⅱ和Ⅳ</p>
<p>C.Ⅰ、Ⅲ和Ⅳ <strong>D.Ⅱ、Ⅲ和Ⅳ</strong></p>
<p>设与某资源相关联的信号量初值为<hanla></hanla>3，当前值为<hanla></hanla>1，若<hanla></hanla>M<hanla></hanla>表示该资源的可用个数，N<hanla></hanla>表示等待该资源的进程数，则<hanla></hanla>M、N<hanla></hanla>分别是 。</p>
<p>A.0，1 <strong>B.1，0</strong></p>
<p>C.1，2 D.2，0</p>
<h2 id="填空题">填空题</h2>
<ol type="1">
<li><p>如果信号量的当前值为-4，则表示系统中在该信号量上有 <strong>4</strong><hanla></hanla>个等待进程。</p></li>
<li><p>对于信号量可以做 P 操作和 V 操作，P<hanla></hanla>操作用于阻塞进程，V 操作用于释放进程。程序中的 P<hanla></hanla>操作应谨慎使用，以保证其使用的正确性，否则执行时可能发生死锁。</p></li>
<li><p>信号量的物理意义是：当信号量值大于<hanla></hanla>0<hanla></hanla>时表示 <strong>可用资源数量</strong>；当信号量值小于<hanla></hanla>0<hanla></hanla>时，其绝对值为 <strong>等待进程数量</strong> 。</p></li>
<li><p>有<hanla></hanla>m<hanla></hanla>个进程共享同一临界资源，若使用信号量机制实现对临界资源的互斥访问，则信号量值的变化范围是<hanla></hanla><strong>1 到 -(m-1)</strong>。</p></li>
<li><p>访问临界资源的进程应该遵循的条件有：<strong>互斥访问</strong>（Mutual Exclusion）、<strong>空闲让进</strong>（Progress）、<strong>有限等待</strong>（Bounded Waiting）、和 <strong>让权等待</strong>（No Busy Waiting。</p></li>
<li><p>临界资源是指<hanla></hanla>__<strong><hanla></hanla>一次仅允许一个进程访问<hanla></hanla></strong>__<hanla></hanla>的资源。</p></li>
<li><p>管程由<strong>共享变量声明</strong>、<strong>操作共享变量的过程（方法）</strong>和 <strong>初始化代码</strong>三部分组成</p></li>
</ol>
<h1 id="第6章-死锁">第<hanla></hanla>6<hanla></hanla>章 死锁</h1>
<h2 id="练习题-5">练习题</h2>
<h3 id="银行家问题">银行家问题</h3>
<p>考虑以下系统快照：</p>
<figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache">    <span class="hljs-attribute">Allocation</span>          Max          Available<br>     <span class="hljs-attribute">A</span> B C D          A B C D         A B C D<br><span class="hljs-attribute">T0</span>   <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span>          <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span>         <span class="hljs-number">1</span> <span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span><br><span class="hljs-attribute">T1</span>   <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>          <span class="hljs-number">1</span> <span class="hljs-number">7</span> <span class="hljs-number">5</span> <span class="hljs-number">0</span><br><span class="hljs-attribute">T2</span>   <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span>          <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span><br><span class="hljs-attribute">T3</span>   <span class="hljs-number">0</span> <span class="hljs-number">6</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span>          <span class="hljs-number">0</span> <span class="hljs-number">6</span> <span class="hljs-number">5</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">T4</span>   <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span>          <span class="hljs-number">0</span> <span class="hljs-number">6</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span><br></code></pre></td></tr></tbody></table></figure>
<p>使用银行家算法回答以下问题： a. 矩阵 <code>Need</code> 的内容是什么？ b. 系统是否处于安全状态？ c.&nbsp;如果线程 T1 请求资源 <code>(0,4,2,0)</code>，是否可以立即批准该请求？</p>
<p><strong>a. 计算 Need 矩阵</strong> Need = Max - Allocation（逐项计算）： • T0: <code>(0-0, 0-0, 1-1, 2-2) = (0,0,0,0)</code></p>
<p>• T1: <code>(1-1, 7-0, 5-0, 0-0) = (0,7,5,0)</code></p>
<p>• T2: <code>(2-1, 3-3, 5-5, 6-4) = (1,0,0,2)</code></p>
<p>• T3: <code>(0-0, 6-6, 5-3, 2-2) = (0,0,2,0)</code></p>
<p>• T4: <code>(0-0, 6-0, 5-1, 6-4) = (0,6,4,2)</code></p>
<p>Need 矩阵： </p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache">   <span class="hljs-attribute">A</span> B C D<br><span class="hljs-attribute">T0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-attribute">T1</span> <span class="hljs-number">0</span> <span class="hljs-number">7</span> <span class="hljs-number">5</span> <span class="hljs-number">0</span><br><span class="hljs-attribute">T2</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">T3</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span><br><span class="hljs-attribute">T4</span> <span class="hljs-number">0</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span><br></code></pre></td></tr></tbody></table></figure><p></p>
<p><strong>b. 检查系统是否处于安全状态</strong></p>
<ol type="1">
<li><p>初始可用资源：<code>Available = (1,5,2,0)</code><br>
</p></li>
<li><p>安全性检查过程： • T0 的 Need 为 <code>(0,0,0,0)</code> ≤ Available，执行后释放资源：</p>
<p>◦ 新 Available = <code>(1+0,5+0,2+1,0+2) = (1,5,3,2)</code></p>
<p>• T3 的 Need 为 <code>(0,0,2,0)</code> ≤ Available <code>(1,5,3,2)</code>，执行后释放资源：</p>
<p>◦ 新 Available = <code>(1+0,5+6,3+3,2+2) = (1,11,6,4)</code></p>
<p>• T4 的 Need 为 <code>(0,6,4,2)</code> ≤ Available <code>(1,11,6,4)</code>，执行后释放资源：</p>
<p>◦ 新 Available = <code>(1+0,11+0,6+1,4+4) = (1,11,7,8)</code></p>
<p>• T1 的 Need 为 <code>(0,7,5,0)</code> ≤ Available <code>(1,11,7,8)</code>，执行后释放资源：</p>
<p>◦ 新 Available = <code>(1+1,11+0,7+0,8+0) = (2,11,7,8)</code></p>
<p>• T2 的 Need 为 <code>(1,0,0,2)</code> ≤ Available <code>(2,11,7,8)</code>，执行后释放资源：</p>
<p>◦ 新 Available = <code>(2+1,11+3,7+5,8+4) = (3,14,12,12)</code></p></li>
<li><p>安全序列：<code>T0 → T3 → T4 → T1 → T2</code> 结论：系统处于安全状态。</p></li>
</ol>
<hr>
<p><strong>c.&nbsp;处理 T1 的请求 (0,4,2,0)</strong> 1. 验证请求合法性： • T1 的 Need 为 <code>(0,7,5,0)</code>，请求 <code>(0,4,2,0)</code> ≤ Need → 合法。</p>
<p>• 请求 <code>(0,4,2,0)</code> ≤ Available <code>(1,5,2,0)</code> → 资源足够。</p>
<ol start="2" type="1">
<li><p>模拟分配： • 更新 Allocation(T1)：<code>(1+0,0+4,0+2,0+0) = (1,4,2,0)</code></p>
<p>• 更新 Need(T1)：<code>(0,7-4,5-2,0) = (0,3,3,0)</code></p>
<p>• 新 Available：<code>(1-0,5-4,2-2,0-0) = (1,1,0,0)</code></p></li>
<li><p>检查新状态是否安全： • 当前 Available = <code>(1,1,0,0)</code></p>
<p>• T0 的 Need <code>(0,0,0,0)</code> ≤ Available → 执行后 Available = <code>(1,1,1,2)</code></p>
<p>• T3 的 Need <code>(0,0,2,0)</code> ≤ Available → 执行后 Available = <code>(1,7,4,4)</code></p>
<p>• T4 的 Need <code>(0,6,4,2)</code> 需要资源 <code>(0,6,4,2)</code>，但 Available = <code>(1,7,4,4)</code> 中 B=7 ≥ 6，C=4 ≥ 4，D=4 ≥ 2 → 可执行，新 Available = <code>(1,7,5,8)</code></p>
<p>• T1 的 Need <code>(0,3,3,0)</code> ≤ Available → 执行后 Available = <code>(2,7,5,8)</code></p>
<p>• T2 的 Need <code>(1,0,0,2)</code> ≤ Available → 执行后 Available = <code>(3,10,10,12)</code></p>
<p>安全序列：<code>T0 → T3 → T4 → T1 → T2</code> 结论：请求可以立即批准。</p></li>
</ol>
<hr>
<p><strong>最终答案：</strong> a. Need 矩阵：<br>
</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">A</span> B C D<br><span class="hljs-attribute">T0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-attribute">T1</span> <span class="hljs-number">0</span> <span class="hljs-number">7</span> <span class="hljs-number">5</span> <span class="hljs-number">0</span><br><span class="hljs-attribute">T2</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">T3</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span><br><span class="hljs-attribute">T4</span> <span class="hljs-number">0</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span><br></code></pre></td></tr></tbody></table></figure> b. 是，系统处于安全状态。 c.&nbsp;是，可以立即批准 T1 的请求。<p></p>
<h2 id="选择题-4">选择题</h2>
<p>要防止死锁的发生，可以通过破坏这四个必要条件之一来实现，但破坏 _____ 条件是不太实际的。</p>
<p>A.<hanla></hanla>循环等待 B.<hanla></hanla>部分分配</p>
<p>C.<hanla></hanla>不可抢占 <strong>D.<hanla></hanla>互斥</strong></p>
<p>为多道程序提供的可共享资源不足时，可能出现死锁。但是，不适当的 _____ 也可能产生死锁。</p>
<p>A.<hanla></hanla>分配队列优先权 <strong>B.<hanla></hanla>进程推进顺序</strong></p>
<p>C.<hanla></hanla>资源的线性分配 D.<hanla></hanla>进程优先权</p>
<p>采用资源剥夺法可以解除死锁，还可以采用 _____ 方法解除死锁。</p>
<p>A.<hanla></hanla>拒绝分配新资源 B.<hanla></hanla>修改信号量</p>
<p>C.<hanla></hanla>执行并行操作 <strong>D.<hanla></hanla>撤消进程</strong></p>
<p>在 _____ 的情况下，系统出现死锁。</p>
<p>A. 计算机系统发生了重大故障</p>
<p>B. 有多个封锁的进程同时存在</p>
<p><strong>C. 若干进程因竞争资源而无休止地相互等待他方释放已占有的资源</strong></p>
<p>D. 资源数大大小于进程数或进程同时申请的资源数大大超过资源总数</p>
<p>银行家算法在解决死锁问题中是用于 _____ 的。</p>
<p>A.<hanla></hanla>检测死锁 B.<hanla></hanla>预防死锁</p>
<p><strong>C.<hanla></hanla>避免死锁</strong> D. 解除死锁</p>
<p>资源的有序分配策略可以破坏 _____ 条件。</p>
<p>A.<hanla></hanla>占有且等待资源 <strong>B.<hanla></hanla>循环等待资源</strong></p>
<p>C. 非抢夺资源 D.<hanla></hanla>互斥使用资源</p>
<p>某系统中有<hanla></hanla>3<hanla></hanla>个并发进程，都需要同类资源<hanla></hanla>4<hanla></hanla>个，试问该系统不会发生死锁的最少资源数是 _____ 。</p>
<p>A. 9 <strong>B. 10</strong></p>
<p>C. 11 D. 12</p>
<p>有序资源分配方法属于<hanla></hanla>_____ 方法。</p>
<p><strong>A．死锁预防</strong> B．死锁避免</p>
<p>C．死锁检测 D．死锁解除</p>
<p>不能防止死锁的资源分配策略是<hanla></hanla>_____。</p>
<p>A．剥夺式分配方式 B．按序分配方式</p>
<p>C．静态分配方式 <strong>D．互斥使用分配方式</strong></p>
<p>某计算机系统中有<hanla></hanla>6<hanla></hanla>台打印机，多个进程均最多需要<hanla></hanla>2<hanla></hanla>台打印机，规定每个进程一次仅允许申请一台打印机。为保证一定不发生死锁，则允许参与打印机资源竞争的最大进程数是<hanla></hanla>__。</p>
<p>A．3 B．4 <strong>C．5</strong> D．6</p>
<p>某计算机中有<hanla></hanla>8<hanla></hanla>台打印机，由<hanla></hanla>K<hanla></hanla>个进程竞争使用，每个进程最多需要<hanla></hanla>3<hanla></hanla>台打印机。该系统可能会发生死锁的<hanla></hanla>K<hanla></hanla>的最小值为（）。</p>
<p>A、2 B、3 <strong>C、4</strong> D、5</p>
<p>某时刻进程的资源使用情况如下表所示：</p>
<p><img src="https://raw.githubusercontent.com/Striver98/Pictures/master/img/image-20250423163852296.png" srcset="/img/loading.gif" lazyload></p>
<p>此时的安全序列是<hanla></hanla>___。</p>
<p>A、P1，P2，P3，P4 B、P1，P3，P2，P4</p>
<p>C、P1，P4，P3，P2 D、不存在</p>
<p><strong>问题分析：</strong> 我们需要根据给定的资源分配情况，判断是否存在一个安全序列，使得所有进程都能顺利完成。安全序列是指一个进程执行顺序，使得每个进程都能获得所需的资源并释放已占用的资源，从而保证系统不会进入死锁状态。</p>
<p><strong>给定数据：</strong> | 进程 | 已分配资源 (Allocation) | 尚需资源 (Need) | 可用资源 (Available) | | —- | ———————– | ————— | ——————– | | | R1 R2 R3 | R1 R2 R3 | R1 R2 R3 | | P1 | 2 0 0 | 0 0 1 | 0 2 1 | | P2 | 1 2 0 | 1 3 2 | | | P3 | 0 1 1 | 1 3 1 | | | P4 | 0 0 1 | 2 0 0 | |</p>
<p><strong>步骤 1：计算当前可用资源 (Available)</strong> 初始可用资源为：<code>Available = (0, 2, 1)</code></p>
<p><strong>步骤 2：寻找可以执行的进程</strong> 我们需要找到一个进程，其尚需资源 (Need) ≤ 当前可用资源 (Available)。</p>
<p>• P1：Need = (0, 0, 1) ≤ Available = (0, 2, 1) → 可以执行</p>
<p>• 执行后，释放已分配资源：<code>Allocation(P1) = (2, 0, 0)</code></p>
<p>• 更新可用资源：<code>Available = (0, 2, 1) + (2, 0, 0) = (2, 2, 1)</code></p>
<p>• P4：Need = (2, 0, 0) ≤ Available = (2, 2, 1) → 可以执行</p>
<p>• 执行后，释放已分配资源：<code>Allocation(P4) = (0, 0, 1)</code></p>
<p>• 更新可用资源：<code>Available = (2, 2, 1) + (0, 0, 1) = (2, 2, 2)</code></p>
<p>• P3：Need = (1, 3, 1) ≤ Available = (2, 2, 2) → 不满足（R2=3 &gt; 2）</p>
<p>• 暂时无法执行。</p>
<p>• P2：Need = (1, 3, 2) ≤ Available = (2, 2, 2) → 不满足（R2=3 &gt; 2）</p>
<p>• 暂时无法执行。</p>
<p><strong>步骤 3：尝试其他顺序</strong> 由于直接执行 P1 后，P4 可以执行，但 P3 和 P2 仍无法执行，我们需要尝试其他顺序。</p>
<p><strong>尝试顺序：P1 → P4 → P3 → P2</strong> 1. P1：执行后，<code>Available = (2, 2, 1)</code> 2. P4：执行后，<code>Available = (2, 2, 2)</code> 3. P3：Need = (1, 3, 1) ≤ Available = (2, 2, 2) → 不满足（R2=3 &gt; 2） • 无法执行。</p>
<p><strong>尝试顺序：P1 → P3 → P4 → P2</strong> 1. P1：执行后，<code>Available = (2, 2, 1)</code> 2. P3：Need = (1, 3, 1) ≤ Available = (2, 2, 1) → 不满足（R2=3 &gt; 2） • 无法执行。</p>
<p><strong>尝试顺序：P1 → P4 → P2 → P3</strong> 1. P1：执行后，<code>Available = (2, 2, 1)</code> 2. P4：执行后，<code>Available = (2, 2, 2)</code> 3. P2：Need = (1, 3, 2) ≤ Available = (2, 2, 2) → 不满足（R2=3 &gt; 2） • 无法执行。</p>
<p><strong>步骤 4：检查其他初始选择</strong> • P4：Need = (2, 0, 0) ≤ Available = (0, 2, 1) → 不满足（R1=2 &gt; 0）</p>
<p>• 无法直接执行。</p>
<p>• P3：Need = (1, 3, 1) ≤ Available = (0, 2, 1) → 不满足（R1=1 &gt; 0, R2=3 &gt; 2）</p>
<p>• 无法直接执行。</p>
<p>• P2：Need = (1, 3, 2) ≤ Available = (0, 2, 1) → 不满足（R1=1 &gt; 0, R2=3 &gt; 2）</p>
<p>• 无法直接执行。</p>
<p><strong>结论：</strong> 唯一可以执行的初始进程是 P1，但执行 P1 后，后续进程无法满足需求，因此不存在安全序列。</p>
<p><strong>最终答案：</strong> D、不存在</p>
<h2 id="填空题-1">填空题</h2>
<p>在有<hanla></hanla>m<hanla></hanla>个进程的系统中出现死锁时，死锁进程的个数<hanla></hanla>k<hanla></hanla>应该满足的条件是<hanla></hanla><strong>2≤<em>k</em>≤<em>m</em></strong>。</p>
<p>银行家算法中，当一个进程提出的资源请求将导致系统从<strong>安全状态</strong>进入 <strong>不安全状态</strong>时，系统就拒绝它的资源请求。</p>
<p>对待死锁，一般应考虑死锁的预防、避免、检测和解除四个问题。典型的银行家算法是属于<strong>死锁避免</strong> ，破坏环路等待条件是属于<strong>死锁预防</strong>，而剥夺资源是<strong>死锁解除</strong>的基本方法。</p>
<h1 id="第7章-内存管理">第<hanla></hanla>7<hanla></hanla>章 内存管理</h1>
<h2 id="页面置换算法">页面置换算法</h2>
<h3 id="先进先出置换算法fifo">先进先出置换算法<hanla></hanla>(FIFO)</h3>
<p><strong>先进先出算法</strong>：选择调入主存时间最长的页面予以淘汰。</p>
<p>特点：该算法实现比较简单，对按线性顺序访问的程序比较合适，但可能产生异常现象。很少使用纯粹的<hanla></hanla>FIFO。</p>
<p>Belady<hanla></hanla>异常：在某些情况下，分配给进程的页面数增多，缺页次数反而增加。</p>
<figure>
<img src="https://raw.githubusercontent.com/Striver98/Pictures/master/img/image-20250425143041731.png" srcset="/img/loading.gif" lazyload alt="采用先进先出算法的页面置换情况"><figcaption aria-hidden="true">采用先进先出算法的页面置换情况</figcaption>
</figure>
<h3 id="最佳置换算法opt">最佳置换算法（OPT）</h3>
<p>最佳算法：也称最优置换算法。从内存中选择最长时间不会使用的页面予以淘汰。</p>
<p>特点：因页面访问的未来顺序很难精确预测，该算法具有理论意义，可以用来评价其他算法的优劣。</p>
<figure>
<img src="https://raw.githubusercontent.com/Striver98/Pictures/master/img/image-20250425143135437.png" srcset="/img/loading.gif" lazyload alt="采用最佳置换算法的页面置换情况"><figcaption aria-hidden="true">采用最佳置换算法的页面置换情况</figcaption>
</figure>
<h3 id="最近最久未使用置换算法lru">最近最久未使用置换算法<hanla></hanla>(LRU)</h3>
<p><strong>最近最久未使用算法</strong>：选择最近一段时间内最长时间没有被访问过的页面予以淘汰。</p>
<p>为此，应赋予每个页面一个访问字段，用于记录页面自上次访问以来所经历的时间。</p>
<p>LRU<hanla></hanla>是<hanla></hanla>Least Recently Used，也称为最近最少使用</p>
<figure>
<img src="https://raw.githubusercontent.com/Striver98/Pictures/master/img/image-20250425143315998.png" srcset="/img/loading.gif" lazyload alt="采用LRU算法的页面置换情况"><figcaption aria-hidden="true">采用<hanla></hanla>LRU<hanla></hanla>算法的页面置换情况</figcaption>
</figure>
<h4 id="lru算法的实现">LRU<hanla></hanla>算法的实现</h4>
<ol type="1">
<li>计数器
<ul>
<li>每个页表项有一个计数器，每次访问页时，把时间拷贝到计数器中。</li>
<li>置换计数器最小值的页</li>
<li>为每个页面配置一个计数器，其初值为<hanla></hanla>0。当进程访问某页时，将计数器的最高位置<hanla></hanla>1，定时器每隔一定时间将计数器右移<hanla></hanla>1<hanla></hanla>位，则数值最小的页是最近最久未使用的页面。</li>
</ul></li>
</ol>
<figure>
<img src="https://raw.githubusercontent.com/Striver98/Pictures/master/img/image-20250425143503151.png" srcset="/img/loading.gif" lazyload alt="计数器实现方法"><figcaption aria-hidden="true">计数器实现方法</figcaption>
</figure>
<ol start="2" type="1">
<li>特殊栈
<ul>
<li>利用一个特殊栈保存当前使用各页的页面号。当进程访问一个页面时，将该页面号从栈中移出压到栈顶。栈底即最近最久未使用的页面号。</li>
</ul></li>
</ol>
<figure>
<img src="https://raw.githubusercontent.com/Striver98/Pictures/master/img/image-20250425143612961.png" srcset="/img/loading.gif" lazyload alt="特殊栈实现方法"><figcaption aria-hidden="true">特殊栈实现方法</figcaption>
</figure>
<h3 id="lru近似置换算法">LRU<hanla></hanla>近似置换算法</h3>
<p>近似<hanla></hanla>LRU<hanla></hanla>算法的基础：引用位（也称访问位）</p>
<ul>
<li>每个页表项都关联一个引用位，初始值为<hanla></hanla>0</li>
<li>当页被访问时将引用位设为<hanla></hanla>1</li>
<li>如果存在引用位为<hanla></hanla>0<hanla></hanla>的页，则置换它</li>
</ul>
<h4 id="附加引用位算法">附加引用位算法</h4>
<p>与前面的计数器实现方法类似</p>
<h4 id="二次机会算法">二次机会算法</h4>
<p>是<hanla></hanla>FIFO<hanla></hanla>算法的改进，以避免将经常使用的页面淘汰掉。</p>
<p>算法思想：使用<hanla></hanla>FIFO<hanla></hanla>算法选择一页淘汰时，先检查该页的引用位，如果是<hanla></hanla>0<hanla></hanla>就立即淘汰该页，如果是<hanla></hanla>1<hanla></hanla>就给它第二次机会，将其引用位清<hanla></hanla>0，并将它放入页面链的末尾，将其装入时间置为当前时间，然后选择下一个页面。</p>
<h3 id="简单时钟clock算法">简单时钟（clock）算法</h3>
<ul>
<li><strong>简单时钟置换算法</strong>既是对二次机会算法的改进，也是对<hanla></hanla>LRU<hanla></hanla>算法的近似。该算法也要求为每页设置一个访问位。</li>
<li>实现思想：将页面排成一个循环队列，类似于时钟表面，并使用一个置换指针。当发生缺页时，检查指针指向的页面，若其访问位为<hanla></hanla>0<hanla></hanla>则淘汰该页，否则将该页的访问位清<hanla></hanla>0，指针前移并重复上述过程，直到找到访问位为<hanla></hanla>0<hanla></hanla>的淘汰页为止。最后指针停留在被置换页的下一页上；</li>
<li>该算法也称为最近未使用（Not Recently Used，NRU）算法。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Striver98/Pictures/master/img/image-20250425144343231.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="改进的时钟算法">改进的时钟算法</h4>
<p>​ 将一个修改过的页面换出需要写磁盘，其开销大于未修改页面。为此在改进型时钟算法中应考虑页面修改情况。设<hanla></hanla>R<hanla></hanla>为访问位，U<hanla></hanla>为修改位，将页面分为以下<hanla></hanla>4<hanla></hanla>种类型：</p>
<ul>
<li>1<hanla></hanla>类<hanla></hanla>(R=0,U=0)：未被访问又未被修改</li>
<li>2<hanla></hanla>类<hanla></hanla>(R=0,U=1)：未被访问但已被修改</li>
<li>3<hanla></hanla>类<hanla></hanla>(R=1,U=0)：已被访问但未被修改</li>
<li>4<hanla></hanla>类<hanla></hanla>(R=1,U=1)：已被访问且已被修改</li>
</ul>
<p>算法描述：</p>
<ul>
<li><p>从指针当前位置开始扫描循环队列，寻找<hanla></hanla>R=0,U=0<hanla></hanla>的页面，将满足条件的第一个页面作为淘汰页。</p></li>
<li><p>若第<hanla></hanla>1<hanla></hanla>步失败，则开始第<hanla></hanla>2<hanla></hanla>轮扫描，寻找<hanla></hanla>R=0,U=1<hanla></hanla>的页面，将满足条件的第一个页面作为淘汰页，并将所有经历过页面的访问位置<hanla></hanla>0。</p></li>
<li><p>若第<hanla></hanla>2<hanla></hanla>步失败，则将指针返回到开始位置，然后重复第<hanla></hanla>1<hanla></hanla>步，若仍失败则必须重复第<hanla></hanla>2<hanla></hanla>步。此时一定能找到淘汰页面。</p></li>
<li><p>特点：减少了磁盘<hanla></hanla>I/O<hanla></hanla>次数，但算法本身开销增加。</p></li>
</ul>
<h3 id="最不经常使用算法lfu">最不经常使用算法（LFU）</h3>
<ul>
<li>选择到当前时间为止访问次数最少的页淘汰。</li>
<li>该算法要求为每页设置一个访问计数器，每当页被访问时，该页的访问计数器加<hanla></hanla>1。发生缺页中断时，淘汰计数值最小的页面，并将所有计数器清零。</li>
</ul>
<h2 id="练习题-6">练习题</h2>
<ol type="1">
<li><strong>为什么页面大小总是<hanla></hanla>2<hanla></hanla>的幂次方？</strong></li>
</ol>
<blockquote>
<ol type="1">
<li><strong>硬件优化</strong>：计算机硬件（如内存管理单元<hanla></hanla>MMU）通过二进制位运算处理地址转换时，2<hanla></hanla>的幂次方能直接利用地址的低位作为页内偏移量，高位作为页号，简化计算（例如取模运算可替换为高效的位掩码操作）。</li>
<li><strong>对齐效率</strong>：2<hanla></hanla>的幂次方对齐能确保内存块整齐划分，减少碎片，提升缓存命中率。例如，CPU<hanla></hanla>缓存行通常也采用<hanla></hanla>2<hanla></hanla>的幂次方大小，与页面对齐可优化数据加载。</li>
<li><strong>地址空间利用</strong>：操作系统分配虚拟地址空间时，2<hanla></hanla>的幂次方大小便于将地址均匀分割，简化管理逻辑（如多级页表的索引计算）。</li>
<li><strong>历史与兼容性</strong>：早期计算机设计采用二进制体系，此约定延续至今，软硬件生态已深度适配</li>
</ol>
</blockquote>
<ol start="2" type="1">
<li><p>给定以下条件：</p>
<ul>
<li><strong>逻辑地址空间</strong>：64 页，每页 1,024 字</li>
<li><strong>物理内存</strong>：32 帧</li>
</ul>
<p>需要计算：</p>
<ol type="a">
<li>逻辑地址的位数</li>
<li>物理地址的位数</li>
</ol></li>
</ol>
<blockquote>
<p><strong>a. 逻辑地址的位数</strong></p>
<p>逻辑地址由 <strong>页号（page number）</strong> 和 <strong>页内偏移量（page offset）</strong> 组成：</p>
<ol type="1">
<li><p><strong>页号位数</strong>：</p>
<ul>
<li>逻辑地址空间有 64 页，因此需要足够多的位数来表示 64 个不同的页号。</li>
<li>计算：log2(64)=6 位。</li>
</ul></li>
<li><p><strong>页内偏移量位数</strong>：</p>
<ul>
<li>每页大小为 1,024 字，因此需要足够多的位数来表示 1,024 个不同的偏移位置。</li>
<li>计算：log2(1024)=10 位。</li>
</ul></li>
<li><p><strong>逻辑地址总位数</strong>：</p>
<p>逻辑地址位数<hanla></hanla>=<hanla></hanla>页号位数<hanla></hanla>+<hanla></hanla>页内偏移量位数<hanla></hanla>=6+10=16 位</p></li>
</ol>
<p><strong>答案 (a)</strong>：逻辑地址有 <strong>16 位</strong>。</p>
<p><strong>b. 物理地址的位数</strong></p>
<p>物理地址由 <strong>帧号（frame number）</strong> 和 <strong>页内偏移量（page offset）</strong> 组成：</p>
<ol type="1">
<li><p><strong>帧号位数</strong>：</p>
<ul>
<li>物理内存有 32 帧，因此需要足够多的位数来表示 32 个不同的帧号。</li>
<li>计算：log2(32)=5 位。</li>
</ul></li>
<li><p><strong>页内偏移量位数</strong>：</p>
<ul>
<li>页内偏移量与逻辑地址相同（因为页大小不变），仍然是 10 位。</li>
</ul></li>
<li><p><strong>物理地址总位数</strong>：</p>
<p>物理地址位数<hanla></hanla>=<hanla></hanla>帧号位数<hanla></hanla>+<hanla></hanla>页内偏移量位数<hanla></hanla>=5+10=15 位</p></li>
</ol>
<p><strong>答案 (b)</strong>：物理地址有 <strong>15 位</strong>。</p>
</blockquote>
<ol start="3" type="1">
<li><p>给定 MPV 操作系统的内存管理参数：</p>
<ul>
<li><strong>虚拟地址（Virtual Address）</strong>：24 位</li>
<li><strong>物理地址（Physical Address）</strong>：20 位</li>
<li><strong>页大小（Page Size）</strong>：4 KB</li>
</ul>
<p>需要计算：</p>
<ol type="1">
<li><strong>(a) 传统单级页表（conventional single-level page table）的条目数</strong></li>
<li><strong>(b) 反向页表（inverted page table）的条目数</strong></li>
<li><strong>MPV 操作系统支持的最大物理内存容量</strong></li>
</ol></li>
</ol>
<blockquote>
<p><strong>1. 分析地址结构</strong> 首先，我们需要分解 虚拟地址 和 物理地址 的结构，以确定页号（page number）和页内偏移量（page offset）的位数。</p>
<ol type="1">
<li>页内偏移量（Page Offset）位数 • 页大小 = 4 KB = <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="2.919ex" height="1.887ex" role="img" focusable="false" viewBox="0 -833.9 1290.1 833.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"></path></g></g></g></g></g></svg></mjx-container>字节</li>
</ol>
<p>• 因此，页内偏移量占 12 位（因为 <span class="math inline">2<sup>12</sup> = 4096</span> ）。</p>
<ol start="2" type="1">
<li>虚拟地址分解（24 位） • 虚拟地址 = 页号（VPN） + 页内偏移量（Offset）</li>
</ol>
<p>• 页号位数 = 虚拟地址位数 - 偏移量位数 =<span class="math inline">24 − 12 = 12</span> 位</p>
<p>• 因此，虚拟页号（VPN）有 12 位，可以表示<hanla></hanla><span class="math inline">2<sup>12</sup> = 4096</span><hanla></hanla>个不同的页。</p>
<ol start="3" type="1">
<li>物理地址分解（20 位） • 物理地址 = 帧号（PFN） + 页内偏移量（Offset）</li>
</ol>
<p>• 由于页内偏移量仍然是 12 位，帧号位数 = 物理地址位数 - 偏移量位数 =<span class="math inline">20 − 12 = 8</span><hanla></hanla>位</p>
<p>• 因此，物理帧号（PFN）有 8 位，可以表示 <span class="math inline">2<sup>8</sup> = 256</span> 个不同的帧。</p>
<hr>
<p><strong>(a) 传统单级页表的条目数</strong> • 传统页表 的条目数由 虚拟页号（VPN） 决定，即每个虚拟页对应一个页表条目。</p>
<p>• 虚拟页号有 12 位，因此页表条目数 = <span class="math inline">2<sup>12</sup> = 4096</span> 个。</p>
<p>答案 (a)：传统单级页表有 4096 个条目。</p>
<hr>
<p><strong>(b) 反向页表的条目数</strong> • 反向页表（Inverted Page Table, IPT） 的条目数由 物理帧号（PFN） 决定，即每个物理帧对应一个反向页表条目。</p>
<p>• 物理帧号有 8 位，因此反向页表条目数 = <span class="math inline">2<sup>8</sup> = 256</span> 个。</p>
<p>答案 (b)：反向页表有 256 个条目。</p>
<hr>
<p><strong>最大物理内存容量</strong> • 物理地址有 20 位，因此可寻址的物理内存空间为<hanla></hanla><span class="math inline">2<sup>20</sup> = 1, 048, 576</span> 字节（即 1 MB）。</p>
<p>• 但题目问的是 最大物理内存，而物理帧数由 帧号位数（8 位） 决定，即最多 256 帧。</p>
<p>• 每帧大小 = 页大小 = 4 KB</p>
<p>• 因此，最大物理内存 = <span class="math inline">256 × 4 KB = 1024 KB = 1 MB</span> 。</p>
<p>答案：MPV 操作系统支持的最大物理内存是 1 MB。</p>
</blockquote>
<ol start="4" type="1">
<li><p>给定一个分页系统，页表存储在内存中：</p>
<ul>
<li><strong>内存访问时间（Memory Access Time）</strong>：50 ns</li>
<li><strong>TLB（Translation Lookaside Buffer）命中率</strong>：75%</li>
<li><strong>TLB 查找时间（TLB Lookup Time）</strong>：2 ns（命中时）</li>
</ul>
<p>需要计算：</p>
<p><strong>(a) 无 TLB 时，分页内存访问的总时间</strong></p>
<p><strong>(b) 有 TLB 时，</strong></p>
<ul>
<li><p>75% 的情况命中 TLB，访问时间 = TLB 查找时间 + 1 次内存访问</p></li>
<li><p>25% 的情况未命中 TLB，访问时间 = TLB 查找时间 + 2 次内存访问（查页表 + 访问数据）</p></li>
<li><p><strong>求有效内存访问时间（Effective Memory Access Time, EMAT）</strong></p></li>
</ul></li>
</ol>
<blockquote>
<p><strong>(a) 无 TLB 时，分页内存访问时间</strong></p>
<p>在 <strong>无 TLB</strong> 的情况下，每次内存访问需要：</p>
<ol type="1">
<li><strong>查页表（1 次内存访问）</strong> → 50 ns</li>
<li><strong>访问目标数据（1 次内存访问）</strong> → 50 ns 因此，总时间 =<span class="math inline"><em>P</em><em>a</em><em>g</em><em>e</em><em>T</em><em>a</em><em>b</em><em>l</em><em>e</em><em>L</em><em>o</em><em>o</em><em>k</em><em>u</em><em>p</em> + <em>M</em><em>e</em><em>m</em><em>o</em><em>r</em><em>y</em><em>A</em><em>c</em><em>c</em><em>e</em><em>s</em><em>s</em> = 50<em>n</em><em>s</em> + 50<em>n</em><em>s</em> = 100<em>n</em><em>s</em></span></li>
</ol>
<p><strong>答案 (a)</strong>：无 TLB 时，分页内存访问时间为 <strong>100 ns</strong>。</p>
<p><strong>(b) 有 TLB 时，有效内存访问时间（EMAT）</strong></p>
<p>TLB 是一种缓存，用于加速页表查找。访问流程如下：</p>
<p><strong>1. TLB 命中（75% 概率）</strong></p>
<ul>
<li><strong>TLB 查找</strong>（2 ns）→ 命中，直接得到物理地址</li>
<li><strong>访问目标数据</strong>（1 次内存访问，50 ns） 总时间 =<span class="math inline"><em>T</em><em>L</em><em>B</em><em>L</em><em>o</em><em>o</em><em>k</em><em>u</em><em>p</em> + <em>M</em><em>e</em><em>m</em><em>o</em><em>r</em><em>y</em><em>A</em><em>c</em><em>c</em><em>e</em><em>s</em><em>s</em> = 2<em>n</em><em>s</em> + 50<em>n</em><em>s</em> = 52<em>n</em><em>s</em></span></li>
</ul>
<p><strong>2. TLB 未命中（25% 概率）</strong></p>
<ul>
<li><strong>TLB 查找</strong>（2 ns）→ 未命中</li>
<li><strong>查页表</strong>（1 次内存访问，50 ns）</li>
<li><strong>访问目标数据</strong>（1 次内存访问，50 ns） 总时间 =<span class="math inline"><em>T</em><em>L</em><em>B</em><em>L</em><em>o</em><em>o</em><em>k</em><em>u</em><em>p</em> + <em>P</em><em>a</em><em>g</em><em>e</em><em>T</em><em>a</em><em>b</em><em>l</em><em>e</em><em>L</em><em>o</em><em>o</em><em>k</em><em>u</em><em>p</em> + <em>M</em><em>e</em><em>m</em><em>o</em><em>r</em><em>y</em><em>A</em><em>c</em><em>c</em><em>e</em><em>s</em><em>s</em> = 2<em>n</em><em>s</em> + 50<em>n</em><em>s</em> + 50<em>n</em><em>s</em> = 102<em>n</em><em>s</em></span></li>
</ul>
<h4 id="计算有效内存访问时间emat"><strong>3. 计算有效内存访问时间（EMAT）</strong></h4>
<p><span class="math inline"><em>E</em><em>M</em><em>A</em><em>T</em> = (<em>T</em><em>L</em><em>B</em><em>H</em><em>i</em><em>t</em><em>R</em><em>a</em><em>t</em><em>e</em> × <em>H</em><em>i</em><em>t</em><em>T</em><em>i</em><em>m</em><em>e</em>) + (<em>T</em><em>L</em><em>B</em><em>M</em><em>i</em><em>s</em><em>s</em><em>R</em><em>a</em><em>t</em><em>e</em> × <em>M</em><em>i</em><em>s</em><em>s</em><em>T</em><em>i</em><em>m</em><em>e</em>)<em>E</em><em>M</em><em>A</em><em>T</em> = (0.75 × 52<em>n</em><em>s</em>) + (0.25 × 102<em>n</em><em>s</em>) = 39<em>n</em><em>s</em> + 25.5<em>n</em><em>s</em> = 64.5<em>n</em><em>s</em></span></p>
<p><strong>答案 (b)</strong>：有 TLB 时，有效内存访问时间为 <strong>64.5 ns</strong></p>
</blockquote>
<ol start="5" type="1">
<li><p>在一个 <strong>固定多道程序度（degree of multiprogramming）为 4</strong> 的请求分页系统中，测量了 <strong>CPU 利用率</strong> 和 <strong>磁盘（分页磁盘）利用率</strong>，得到以下三种情况：</p>
<ol type="1">
<li><strong>(a) CPU 利用率 13%；磁盘利用率 97%</strong></li>
<li><strong>(b) CPU 利用率 87%；磁盘利用率 3%</strong></li>
<li><strong>(c) CPU 利用率 13%；磁盘利用率 3%</strong></li>
</ol>
<p><strong>问题</strong>：</p>
<ol type="1">
<li><strong>每种情况下发生了什么？</strong></li>
<li><strong>能否通过增加多道程序度来提高 CPU 利用率？</strong></li>
</ol></li>
</ol>
<blockquote>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">情况</th>
<th style="text-align: center;">CPU 利用率</th>
<th style="text-align: center;">磁盘利用率</th>
<th style="text-align: center;">系统状态</th>
<th style="text-align: center;">能否增加多道程序度？</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>(a)</strong></td>
<td style="text-align: center;">13%</td>
<td style="text-align: center;">97%</td>
<td style="text-align: center;"><strong>抖动（Thrashing）</strong></td>
<td style="text-align: center;">❌ <strong>不能，应减少</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>(b)</strong></td>
<td style="text-align: center;">87%</td>
<td style="text-align: center;">3%</td>
<td style="text-align: center;"><strong>运行良好</strong></td>
<td style="text-align: center;">⚠️ <strong>可尝试增加，但需监控</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>(c)</strong></td>
<td style="text-align: center;">13%</td>
<td style="text-align: center;">3%</td>
<td style="text-align: center;"><strong>进程数不足或 I/O 密集型</strong></td>
<td style="text-align: center;">✅ <strong>可以增加</strong></td>
</tr>
</tbody>
</table>
<h3 id="关键结论"><strong>关键结论</strong></h3>
<ul>
<li><strong>抖动（Thrashing）</strong> 发生时（高磁盘利用率 + 低 CPU 利用率），<strong>不能增加多道程序度</strong>，反而应该减少。</li>
<li><strong>系统运行良好</strong>（高 CPU 利用率 + 低磁盘利用率）时，可以 <strong>谨慎增加</strong> 多道程序度，但需监控是否接近抖动阈值。</li>
<li><strong>CPU 和磁盘都空闲</strong>（低 CPU + 低磁盘）时，通常 <strong>可以增加多道程序度</strong>，以提高 CPU 利用率。</li>
</ul>
</blockquote>
<h2 id="选择题-5">选择题</h2>
<ol type="1">
<li>首次适应算法的空白区是 _____ 。</li>
</ol>
<p>A. 按大小递减顺序连在一起</p>
<p>B. 按地址由大到小排列</p>
<p><strong>C. 按地址由小到大排列</strong></p>
<p>D. 按大小递增顺序连在一起</p>
<ol start="2" type="1">
<li>在分区存储管理中的拼接技术可以 _____ 。</li>
</ol>
<p>A. 缩短访问周期 B. 增加内存容量</p>
<p><strong>C.<hanla></hanla>集中空闲区</strong> D. 加速地址转换</p>
<ol start="3" type="1">
<li>采用 _____ 不会产生内部碎片。</li>
</ol>
<p>A.<hanla></hanla>分页存储管理</p>
<p>B.<hanla></hanla>固定分区存储管理</p>
<p><strong>C.<hanla></hanla>分段存储管理</strong></p>
<p>D.<hanla></hanla>段页式存储管理</p>
<ol start="4" type="1">
<li>采用分段存储管理的系统中，若地址用<hanla></hanla>24<hanla></hanla>位表示，其中<hanla></hanla>8<hanla></hanla>位表示段号，则允许每段的最大长度是 _____ 。</li>
</ol>
<p><strong>A. <span class="math inline">2<sup>16</sup></span></strong> B. <span class="math inline">2<sup>32</sup></span> C. <span class="math inline">2<sup>24</sup></span> D. <span class="math inline">2<sup>8</sup></span></p>
<ol start="5" type="1">
<li>在固定分区分配中，每个分区的大小是 _____ 。</li>
</ol>
<p><strong>A.<hanla></hanla>可以不同但预先固定</strong></p>
<p>B.<hanla></hanla>相同</p>
<p>C.<hanla></hanla>随作业长度变化</p>
<p>D.<hanla></hanla>可以不同但根据作业长度固定</p>
<ol start="6" type="1">
<li>把作业地址空间使用的逻辑地址变成内存的物理地址称为 _____ 。</li>
</ol>
<p>A.<hanla></hanla>加载 <strong>B.<hanla></hanla>重定位</strong></p>
<p>C.<hanla></hanla>物理化 D.<hanla></hanla>逻辑化</p>
<ol start="7" type="1">
<li>在以下存储管理方案中，不适用于多道程序设计系统的是 _____ 。</li>
</ol>
<p>A.<hanla></hanla>固定式分区分配 <strong>B.<hanla></hanla>单一连续分配</strong></p>
<p>C.<hanla></hanla>可变式分区分配 D.<hanla></hanla>页式存储管理</p>
<ol start="8" type="1">
<li>在可变式分区分配方案中，某一作业完成后，系统收回其内存空间并与相邻空闲区合并，为此需修改空闲区表，造成空闲区数减<hanla></hanla>1<hanla></hanla>的情况是 _____ 。</li>
</ol>
<p>A.<hanla></hanla>有下邻空闲区但无上邻空闲区</p>
<p>B.<hanla></hanla>有上邻空闲区但无下邻空闲区</p>
<p><strong>C.<hanla></hanla>有上邻空闲区也有下邻空闲区</strong></p>
<p>D.<hanla></hanla>无上邻空闲区也无下邻空闲区</p>
<ol start="9" type="1">
<li>采用两级页表的页式存储管理中，按给定的逻辑地址进行读写时，通常需访问主存的次数是<hanla></hanla>_____ 。</li>
</ol>
<p>A. 1<hanla></hanla>次 B. 2<hanla></hanla>次 <strong>C. 3<hanla></hanla>次</strong> D. 4<hanla></hanla>次</p>
<ol start="10" type="1">
<li>分页系统中的页面是<hanla></hanla>_____。</li>
</ol>
<p>A．用户感知的 <strong>B．操作系统感知的</strong></p>
<p>C．编译程序感知的 D．链接装配程序感知的</p>
<ol start="11" type="1">
<li>下述内存分配算法中，_____ 更易产生无法利用的小碎片。</li>
</ol>
<p>A．首次适应算法 B．循环首次适应算法</p>
<p><strong>C．最佳适应算法</strong> D．最坏适应算法</p>
<ol start="12" type="1">
<li>实现虚拟存储器的目的是 _____ 。</li>
</ol>
<p>A. 实现存储保护 B. 实现程序浮动</p>
<p>C. 扩充辅存容量 <strong>D. 扩充内存容量</strong></p>
<ol start="13" type="1">
<li>页式虚拟存储管理的主要特点是 _____ 。</li>
</ol>
<p>A. 不要求将作业装入到内存的连续区域</p>
<p><strong>B. 不要求将作业同时全部装入到内存的连续区域</strong></p>
<p>C. 不要求进行缺页中断处理</p>
<p>D. 不要求进行页面置换</p>
<ol start="14" type="1">
<li>作业在执行中发生了缺页中断，经操作系统处理后，应让其执行 _____ 指令。</li>
</ol>
<p>A. 被中断的前一条 <strong>B. 被中断的那条</strong></p>
<p>C. 被中断的后一条 D. 启动时的第一条</p>
<ol start="15" type="1">
<li>虚拟存储管理系统的基础是程序的 _____ 理论。</li>
</ol>
<p><strong>A. 局部性</strong> B. 全局性</p>
<p>C. 动态性 D. 虚拟性</p>
<ol start="16" type="1">
<li>在以下存储管理方案中，属于虚拟存储器管理的是 _____ 。</li>
</ol>
<p>A. 可重定位分区分配 B. 分段存储管理</p>
<p><strong>C. 请求分页存储管理</strong> D. 段页式存储管理</p>
<ol start="17" type="1">
<li>由于实现<hanla></hanla>_____ 页面置换算法的成本高，通常使用一种近似的页面置换算法<hanla></hanla>_____<hanla></hanla>算法。</li>
</ol>
<p>A.Optimal LRU <strong>B.LRU Clock</strong></p>
<p>C.FCFS Clock D.Clock 改进的<hanla></hanla>Clock</p>
<ol start="18" type="1">
<li>会产生<hanla></hanla>Belady<hanla></hanla>异常现象的页面置换算法是<hanla></hanla>_____。</li>
</ol>
<p>A．最佳页面置换算法</p>
<p><strong>B．先进先出页面置换算法</strong></p>
<p>C．最近最久未使用置换算法</p>
<p>D．最少使用页面置换算法</p>
<ol start="19" type="1">
<li>在请求分页存储管理系统中，下述<hanla></hanla>_____<hanla></hanla>策略是不适用的</li>
</ol>
<p>A．固定分配局部置换 <strong>B．固定分配全局置换</strong></p>
<p>C．可变分配全局置换 D．可变分配局部置换</p>
<ol start="20" type="1">
<li>二次机会置换算法与简单时钟置换算法在决定淘汰哪一页时，都用到了<hanla></hanla>_____。</li>
</ol>
<p>A．快表 <strong>B．引用位</strong></p>
<p>C．修改位 D．存在位</p>
<ol start="21" type="1">
<li>请求段页式系统<hanla></hanla>_____。</li>
</ol>
<p>A．是以页为单位管理用户的虚空间，以段为单位管理内存空间。</p>
<p><strong>B．是以段为单位管理用户的虚空间，以页为单位管理内存空间。</strong></p>
<p>C．是以连续的内存区存放每个段。</p>
<p>D．为提高内存利用率，允许用户使用大小不同的页。</p>
<h2 id="填空题-2">填空题</h2>
<ol type="1">
<li><p>在分区分配算法中，首次适应算法倾向于优先利用内存中的 <strong>低地址</strong>部分的空闲分区，从而保留了<strong>高地址</strong>部分的大空闲区。</p></li>
<li><p>段页式存储管理中，是先将作业分<strong>段</strong> ， <strong>段</strong>内分<strong>页</strong>。分配以 <strong>页</strong>为单位。在不考虑使用联想存储器的情况下，执行程序时需要 <strong>3</strong><hanla></hanla>次访问内存，其中第 <strong>2</strong><hanla></hanla>次是查作业的页表。</p></li>
<li><p>把作业装入内存中随即进行地址变换的方式称为<strong>静态重定位</strong>，而在作业执行期间，当访问到指令或数据时才进行地址变换的方式称为 <strong>动态重定位</strong>。</p></li>
<li><p>三种不连续内存管理方式是：<strong>分页</strong>、<strong>分段</strong>和 <strong>段页式</strong>。</p></li>
<li><p>分区存储管理可以分为：<strong>固定</strong>分区和<strong>动态</strong>分区。</p></li>
<li><p>在请求页式存储管理系统中，常用的页面淘汰算法有：<strong>最佳置换算法（OPT）</strong>，选择淘汰不再使用或最远的将来才使用的页；<strong>先进先出算法（FIFO）</strong>，选择淘汰在内存驻留时间最长的页。</p></li>
<li><p>程序运行时的局部性表现为： <strong>时间局部性</strong>和<strong>空间局部性</strong>。</p></li>
<li><p>虚拟存储器的特点是<strong>部分装入</strong>、<strong>按需调页</strong>、<strong>逻辑扩展内存</strong>、<strong>透明性</strong>。</p></li>
<li><p>所谓虚拟存储器是指具有 <strong>请求调入</strong> 和 <strong>置换</strong>功能，能从逻辑上对内存容量进行扩充的一种存储器系统。</p></li>
<li><p>虚拟存储器的实现方法有三种<strong>请求分页</strong>、 <strong>请求分段</strong>和 <strong>段页式</strong> 。</p></li>
<li><p>在请求页式系统中，当访问的页不在主存时，由<strong>缺页中断机制</strong>将该页调入内存；当主存无空闲块时，必须<strong>置换（或淘汰）</strong>一页。</p></li>
</ol>
<h2 id="考研题">考研题</h2>
<ol type="1">
<li>分区分配内存管理方式的主要保护措施是（）。</li>
</ol>
<p><strong>A、界地址保护</strong> B、程序代码保护</p>
<p>C、数据保护 D、栈保护</p>
<ol start="2" type="1">
<li>一个分段存储管理系统中，地址长度为<hanla></hanla>32<hanla></hanla>位，其中段号占<hanla></hanla>8<hanla></hanla>位，则最大段长为（）。</li>
</ol>
<p>A、2^8<hanla></hanla>字节 B、2^16<hanla></hanla>字节</p>
<p>**C、2<sup>24<hanla></hanla>字节<hanla></hanla>** D、2</sup>32<hanla></hanla>字节</p>
<ol start="3" type="1">
<li><p>某基于动态分区存储管理的计算机，其主存容量为<hanla></hanla>55MB（初始为空），采用最佳适配算法，分配和释放的顺序为：分配<hanla></hanla>15MB，分配<hanla></hanla>30MB，释放<hanla></hanla>15MB，分配<hanla></hanla>8MB，分配<hanla></hanla>6MB，此时主存中最大空闲分区的大小是</p>
<p>A.7MB <strong>B.9MB</strong> C.10MB D.15MB</p></li>
</ol>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">操作</th>
<th style="text-align: center;">空闲分区表（分配前）</th>
<th style="text-align: center;">分配<hanla></hanla>/<hanla></hanla>释放操作</th>
<th style="text-align: center;">空闲分区表（分配后）</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">初始</td>
<td style="text-align: center;"><code>[55MB]</code></td>
<td style="text-align: center;">-</td>
<td style="text-align: center;"><code>[55MB]</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">分配 15MB</td>
<td style="text-align: center;"><code>[55MB]</code></td>
<td style="text-align: center;">从 55MB 中分配 15MB</td>
<td style="text-align: center;"><code>[40MB]</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">分配 30MB</td>
<td style="text-align: center;"><code>[40MB]</code></td>
<td style="text-align: center;">从 40MB 中分配 30MB</td>
<td style="text-align: center;"><code>[10MB]</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">释放 15MB</td>
<td style="text-align: center;"><code>[10MB]</code></td>
<td style="text-align: center;">释放 15MB</td>
<td style="text-align: center;"><code>[10MB, 15MB]</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">分配 8MB</td>
<td style="text-align: center;"><code>[10MB, 15MB]</code></td>
<td style="text-align: center;">从 10MB 中分配 8MB</td>
<td style="text-align: center;"><code>[2MB, 15MB]</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">分配 6MB</td>
<td style="text-align: center;"><code>[2MB, 15MB]</code></td>
<td style="text-align: center;">从 15MB 中分配 6MB</td>
<td style="text-align: center;"><code>[2MB, 9MB]</code></td>
</tr>
</tbody>
</table>
<ol start="4" type="1">
<li><p>某计算机采用 <strong>二级页表</strong> 的分页存储管理方式，按字节编址，具体参数如下：</p>
<ul>
<li><strong>页大小</strong>：<span class="math inline">2<sup>10</sup></span> 字节（1KB）。</li>
<li><strong>页表项大小</strong>：2 字节。</li>
<li><strong>逻辑地址结构</strong>：<code>页目录号 | 页号 | 页内偏移量</code>。</li>
<li><strong>逻辑地址空间大小</strong>：<span class="math inline">2<sup>16</sup></span> 页。</li>
</ul>
<p><strong>问题</strong>：表示整个逻辑地址空间的 <strong>页目录表（一级页表）</strong> 中，包含的表项个数至少是多少？ ​<strong>​选项​</strong>​：A. 64 B. 128 C. 256 D. 512</p></li>
</ol>
<p><strong>解题步骤</strong></p>
<p><strong>1. 理解二级页表结构</strong></p>
<ul>
<li><strong>二级页表</strong> 的地址转换流程：
<ol type="1">
<li>根据 <strong>页目录号</strong> 查找页目录表（一级页表），获取二级页表的基址。</li>
<li>根据 <strong>页号</strong> 查找二级页表，获取物理页框号。</li>
<li>结合 <strong>页内偏移量</strong> 访问物理内存。</li>
</ol></li>
<li><strong>逻辑地址空间</strong>：
<ul>
<li>总页数 = 216 页。</li>
<li>每页大小 = 210 字节 → <strong>逻辑地址空间总大小</strong> = 216×210=226 字节（64MB）。</li>
</ul></li>
</ul>
<p><strong>2. 计算页目录表的表项数</strong></p>
<ul>
<li><strong>页目录表（一级页表）</strong> 的每个表项指向一个 <strong>二级页表</strong>。</li>
<li><strong>关键问题</strong>：需要多少个二级页表才能覆盖 216 个逻辑页？</li>
</ul>
<p><strong>步骤</strong>：</p>
<ol type="1">
<li><strong>每个二级页表能映射多少页</strong>？
<ul>
<li>页大小 = 210 字节，页表项大小 = 2 字节。</li>
<li><strong>每张二级页表的表项数</strong> = 2210=29=512 项（即每张二级页表可映射 512 页）。</li>
</ul></li>
<li><strong>需要的二级页表总数</strong>：
<ul>
<li>总逻辑页数 = 216 页。</li>
<li>每张二级页表映射 512 页 → <strong>二级页表数量</strong> = 29216=27=128 个。</li>
</ul></li>
<li><strong>页目录表的表项数</strong>：
<ul>
<li>页目录表需要 <strong>128 个表项</strong>（每个表项指向一个二级页表）。</li>
</ul></li>
</ol>
<p><strong>3. 验证逻辑地址划分</strong></p>
<ul>
<li><p>逻辑地址结构：</p>
<figure class="highlight gherkin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gherkin"><hanla></hanla>页目录号 |<span class="hljs-string"> 页号 </span>|<span class="hljs-string"> 页内偏移量</span><br></code></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>页内偏移量</strong>：10 位（210 字节页大小）。</li>
<li><strong>页号</strong>：9 位（每张二级页表 512 项，29）。</li>
<li><strong>页目录号</strong>：剩余位数 = 26 - 10 - 9 = 7 位 → 27=128 个表项。</li>
</ul></li>
</ul>
<h1 id="第8章-文件系统">第<hanla></hanla>8<hanla></hanla>章 文件系统</h1>
<h2 id="练习题-7">练习题</h2>
<ol type="1">
<li>解释<hanla></hanla><code>open()</code><hanla></hanla>和<hanla></hanla><code>close()</code><hanla></hanla>操作的作用。</li>
</ol>
<ul>
<li><strong><code>open()</code><hanla></hanla>操作</strong>：用于打开一个资源（如文件、数据库连接等），使其可被访问或修改。例如，在文件操作中，<code>open()</code><hanla></hanla>会建立程序与文件之间的连接，返回一个文件对象供后续读写。</li>
<li><strong><code>close()</code><hanla></hanla>操作</strong>：用于释放资源并终止与对象的连接。例如，关闭文件会确保数据写入磁盘并释放系统资源，避免内存泄漏或数据损坏。</li>
</ul>
<ol start="2" type="1">
<li>现有文件由<hanla></hanla>100<hanla></hanla>个块组成。假设文件控制块（以及索引分配的索引块）已在内存中。计算在以下情况下，<strong>连续分配、链接分配和单级索引分配</strong>策略所需的磁盘<hanla></hanla>I/O<hanla></hanla>操作次数（假设新增块的信息已在内存中）：
<ul>
<li><strong>a.</strong> 在文件开头添加一个块</li>
<li><strong>b.</strong> 在文件中间添加一个块</li>
<li><strong>c.</strong> 在文件末尾添加一个块</li>
<li><strong>d.</strong> 从文件开头删除一个块</li>
<li><strong>e.</strong> 从文件中间删除一个块</li>
<li><strong>f.</strong> 从文件末尾删除一个块</li>
</ul></li>
</ol>
<p><strong>分配策略概述</strong></p>
<ol type="1">
<li><strong>连续分配</strong>：文件块在磁盘上连续存储，需移动数据以腾出空间。</li>
<li><strong>链接分配</strong>：每个块包含指向下一个块的指针，无需移动数据，但需遍历链表。</li>
<li><strong>索引分配（单级）</strong>：索引块存储所有块的指针，修改索引块即可。</li>
</ol>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><strong>操作</strong></th>
<th style="text-align: center;"><strong>连续分配</strong></th>
<th style="text-align: center;"><strong>链接分配</strong></th>
<th style="text-align: center;"><strong>索引分配</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>a. 开头添加块</strong></td>
<td style="text-align: center;">101（移动全部块）</td>
<td style="text-align: center;">1（更新头指针<hanla></hanla>+<hanla></hanla>新块）</td>
<td style="text-align: center;">1（更新索引块）</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>b. 中间添加块</strong></td>
<td style="text-align: center;">51（移动后半部分）</td>
<td style="text-align: center;">51（遍历到中间<hanla></hanla>+<hanla></hanla>更新指针）</td>
<td style="text-align: center;">1（更新索引块）</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>c.&nbsp;末尾添加块</strong></td>
<td style="text-align: center;">1（直接追加）</td>
<td style="text-align: center;">1（更新尾指针<hanla></hanla>+<hanla></hanla>新块）</td>
<td style="text-align: center;">1（更新索引块）</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>d.&nbsp;开头删除块</strong></td>
<td style="text-align: center;">0（仅更新<hanla></hanla>FCB）</td>
<td style="text-align: center;">1（更新头指针）</td>
<td style="text-align: center;">1（更新索引块）</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>e. 中间删除块</strong></td>
<td style="text-align: center;">49（移动后半部分）</td>
<td style="text-align: center;">51（遍历到中间<hanla></hanla>+<hanla></hanla>更新指针）</td>
<td style="text-align: center;">1（更新索引块）</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>f.&nbsp;末尾删除块</strong></td>
<td style="text-align: center;">0（仅更新<hanla></hanla>FCB）</td>
<td style="text-align: center;">100（遍历到尾节点）</td>
<td style="text-align: center;">1（更新索引块）</td>
</tr>
</tbody>
</table>
<h2 id="选择题-6">选择题</h2>
<ol type="1">
<li>操作系统中对外存上的数据信息进行管理的部分叫做 _____ 。</li>
</ol>
<p>A. 数据库系统 <strong>B. 文件系统</strong></p>
<p>C. 检索系统 D. 数据存储系统</p>
<ol start="2" type="1">
<li>文件系统中，打开文件（open）操作的功能是 。</li>
</ol>
<p>A. 把文件信息从辅存读到内存</p>
<p>B. 把磁盘的超级块从辅存读到内存</p>
<p>C. 把文件的<hanla></hanla>FAT<hanla></hanla>表信息从辅存读到内存</p>
<p><strong>D. 把文件的控制管理信息从辅存读到内存</strong></p>
<ol start="3" type="1">
<li>文件的绝对路径名是指 _____ 。</li>
</ol>
<p>A. 文件名和文件扩展名</p>
<p>B. 一系列的目录文件名和该文件的文件名</p>
<p><strong>C. 从根目录到该文件所经历的路径中各符号名的集合</strong></p>
<p>D. 目录文件名和文件名的集合</p>
<ol start="4" type="1">
<li>为了解决不同用户文件的<hanla></hanla>“命名冲突”<hanla></hanla>问题，通常在文件系统中采用 _____ 。</li>
</ol>
<p>A. 约定的方法 <strong>B. 多级目录</strong></p>
<p>C. 路径 D. 索引</p>
<ol start="5" type="1">
<li>一个文件的相对路径名是从 _____ 开始，逐步沿着各级子目录追溯，最后到指定文件的整个通路上所有子目录名组成的一个字符串。</li>
</ol>
<p><strong>A. 当前目录</strong> B. 根目录</p>
<p>C. 二级目录 D. 多级目录</p>
<ol start="6" type="1">
<li>使用文件前必须先 ① 文件，文件使用完毕后应该 ② 。<strong>B，D</strong></li>
</ol>
<p>A. 建立 <strong>B. 打开</strong></p>
<p>C. 命名 <strong>D. 关闭</strong></p>
<ol start="7" type="1">
<li>在文件系统中，文件的不同物理结构有不同的优缺点。在下列文件的物理结构中， ① 不具有直接读写文件任意一个记录的能力， ② 不利于文件长度动态增长。<strong>B，A</strong></li>
</ol>
<p>A. 顺序结构 B. 链接结构</p>
<p>C. 索引结构 D. Hash<hanla></hanla>结构</p>
<ol start="8" type="1">
<li>文件系统采用二级目录结构，这样可以 _____ 。</li>
</ol>
<p>A. 缩短访问文件存储器时间</p>
<p>B. 实现文件共享</p>
<p>C. 解决不同用户之间的文件名冲突问题</p>
<p>D.<hanla></hanla>节省主存空间</p>
<ol start="9" type="1">
<li>常用的文件存取方法有两种：顺序存取和 _____ 存取。</li>
</ol>
<p>A. 流式 B. 串联</p>
<p>C. 记录 <strong>D. 随机</strong></p>
<ol start="10" type="1">
<li>位示图可用于 _____ 。</li>
</ol>
<p>A. 文件目录的查找</p>
<p><strong>B. 磁盘空间的管理</strong></p>
<p>C. 主存空间的共享</p>
<p>D. 实现文件的保护和保密</p>
<h2 id="填空题-3">填空题</h2>
<ol type="1">
<li>索引文件大体上由 <strong>索引区</strong>和 <strong>数据区</strong>构成。</li>
<li>逻辑文件有两种类型，即 <strong>流式文件</strong>与<strong>记录式文件</strong>。</li>
<li>文件的物理组织有顺序结构、<strong>链接结构</strong>和索引结构。</li>
<li>在文件系统中，要求物理块必须连续的物理文件是<strong>顺序文件</strong>。</li>
<li>文件转储的方法有两种：全量转储和<strong>增量转储</strong>。</li>
<li>文件的结构就是文件的组织形式，从用户观点出发所看到的文件组织形式称为文件的<strong>逻辑结构</strong>；从实现观点出发，文件在外存上的存放组织形式称为文件的<strong>物理结构</strong>。</li>
<li>文件系统中若文件的物理结构采用连续结构，则文件控制块中关于文件的物理位置信息应包括文件的<strong>起始块号</strong>和 <strong>文件长度</strong>。</li>
<li>二级目录结构通常由<strong>主文件目录（MFD）</strong>和各用户的 <strong>用户文件目录（UFD）</strong>组成。</li>
<li>按用户对文件的存取权限将用户分为若干组，同时规定每一组用户对文件的访问权限。这样，所有用户组存取权限的集合称为该文件的<strong>访问控制表（ACL，Access Control List）</strong>。</li>
<li><strong>文件保护（File Protection）</strong>是指避免文件拥有者或其他用户因有意或无意的错误操作使文件受到破坏。</li>
</ol>
<h2 id="考研题-1">考研题</h2>
<ol type="1">
<li><p>设文件索引节点中有<hanla></hanla>7<hanla></hanla>个地址项，其中<hanla></hanla>4<hanla></hanla>个地址项为直接地址索引，2<hanla></hanla>个地址项是一级间接地址索引，1<hanla></hanla>个地址项是二级间接地址索引，每个地址项大小为<hanla></hanla>4<hanla></hanla>字节，若磁盘索引块和磁盘数据块大小均为<hanla></hanla>256<hanla></hanla>字节，则可表示的单个文件最大长度是 。</p>
<p>A.33KB B. 519KB C. 1057KB D. 16613KB</p></li>
</ol>
<h4 id="解题步骤">解题步骤</h4>
<ol type="1">
<li>理解索引节点结构</li>
</ol>
<p>索引节点（inode）用于存储文件的元数据，包括指向文件数据块的指针。题目中给出了<hanla></hanla>7<hanla></hanla>个地址项：</p>
<ul>
<li><strong>4<hanla></hanla>个直接地址索引</strong>：直接指向数据块。</li>
<li><strong>2<hanla></hanla>个一级间接地址索引</strong>：指向一个索引块，该索引块中存储多个指向数据块的指针。</li>
<li><strong>1<hanla></hanla>个二级间接地址索引</strong>：指向一个索引块，该索引块中的指针指向其他索引块，这些索引块再指向数据块。</li>
</ul>
<ol start="2" type="1">
<li>计算每个地址项能指向的数据块数量</li>
</ol>
<ul>
<li><strong>直接地址索引</strong>：每个直接指向一个数据块。
<ul>
<li>4<hanla></hanla>个直接地址索引 → 4<hanla></hanla>个数据块。</li>
</ul></li>
<li><strong>一级间接地址索引</strong>：
<ul>
<li>每个索引块大小为<hanla></hanla>256<hanla></hanla>字节，每个地址项（指针）大小为<hanla></hanla>4<hanla></hanla>字节。</li>
<li>一个索引块可以存储的指针数量 = 256 / 4 = 64<hanla></hanla>个。</li>
<li>每个一级间接地址索引指向一个索引块，因此可以指向<hanla></hanla>64<hanla></hanla>个数据块。</li>
<li>2<hanla></hanla>个一级间接地址索引 → 2 × 64 = 128<hanla></hanla>个数据块。</li>
</ul></li>
<li><strong>二级间接地址索引</strong>：
<ul>
<li>二级间接索引的第一层是一个索引块，存储指向第二层索引块的指针。</li>
<li>第二层每个索引块又可以指向<hanla></hanla>64<hanla></hanla>个数据块。</li>
<li>因此，一个二级间接地址索引可以指向的数据块数量 = 64 × 64 = 4096<hanla></hanla>个。</li>
<li>1<hanla></hanla>个二级间接地址索引 → 4096<hanla></hanla>个数据块。</li>
</ul></li>
</ul>
<ol start="3" type="1">
<li>计算总数据块数量</li>
</ol>
<p>将直接、一级间接和二级间接索引指向的数据块数量相加：</p>
<ul>
<li>直接：4<hanla></hanla>块</li>
<li>一级间接：128<hanla></hanla>块</li>
<li>二级间接：4096<hanla></hanla>块</li>
<li>总数据块数量 = 4 + 128 + 4096 = 4228<hanla></hanla>块。</li>
</ul>
<ol start="4" type="1">
<li>计算文件最大长度</li>
</ol>
<ul>
<li>每个数据块大小为<hanla></hanla>256<hanla></hanla>字节。</li>
<li>文件最大长度 = 总数据块数量 × 数据块大小 = 4228 × 256<hanla></hanla>字节。</li>
</ul>
<p>计算： 4228 × 256 = 4228 × (250 + 6) = 4228 × 250 + 4228 × 6 = 1,057,000 + 25,368 = 1,082,368<hanla></hanla>字节。</p>
<p>转换为<hanla></hanla>KB： 1,082,368<hanla></hanla>字节 ÷ 1024 = 1057KB。</p>
<ol start="5" type="1">
<li>验证选项</li>
</ol>
<p>计算结果是<hanla></hanla>1057KB，对应选项<hanla></hanla>C。</p>
<ol start="2" type="1">
<li>某文件系统空间的最大容量为<hanla></hanla>4TB（1TB=<span class="math inline">2<sup>40</sup></span>），以磁盘块为基本分配单元。磁盘块大小为<hanla></hanla>1KB。文件控制块（FCB）包含一个<hanla></hanla>512B<hanla></hanla>的索引表区。请回答下列问题。</li>
</ol>
<p>（1）假设索引表区仅采用直接索引结构，索引表区存放文件占用的磁盘块号，索引项中块号最少占多少字节？可支持的单个文件最大长度是多少字节？</p>
<p>（2）假设索引表区采用如下结构：第<hanla></hanla>0～7<hanla></hanla>字节采用<hanla></hanla>&lt;起始块号，块数&gt;<hanla></hanla>格式表示文件创建时预分配的连续存储空间。其中起始块号占<hanla></hanla>6B，块数占<hanla></hanla>2B，剩余<hanla></hanla>504<hanla></hanla>字节采用直接索引结构，一个索引项占<hanla></hanla>6B，则可支持的单个文件最大长度是多少字节？为了使单个文件的长度达到最大，请指出起始块号和块数分别所占字节数的合理值并说明理由。</p>
<p><img src="https://blogwzx.oss-cn-beijing.aliyuncs.com/image-20250504170330412.png" srcset="/img/loading.gif" lazyload></p>
<ol start="3" type="1">
<li>下列文件物理结构中，适合随机访问且易于文件扩展的是（）</li>
</ol>
<p>A、连续结构 C、链式结构且磁盘块定长</p>
<p><strong>B、索引结构</strong> D、链式结构且磁盘块变长</p>
<ol start="4" type="1">
<li>设置当前工作目录的主要目的是 。</li>
</ol>
<p>A. 节省外存空间 B. 节省内存空间</p>
<p><strong>C. 加快文件的检索速度</strong> D. 加快文件的读<hanla></hanla>/<hanla></hanla>写速度</p>
<ol start="5" type="1">
<li>文件系统中，文件访问控制信息存储的合理位置是（）。</li>
</ol>
<p><strong>A、文件控制块</strong> B、文件分配表</p>
<p>C、用户口令表 D、系统注册表</p>
<ol start="6" type="1">
<li>设文件<hanla></hanla>F1<hanla></hanla>的当前连接计数为<hanla></hanla>1，先建立<hanla></hanla>F1<hanla></hanla>的符号链接（软连接）文件<hanla></hanla>F2，再建立<hanla></hanla>F1<hanla></hanla>的硬链接文件<hanla></hanla>F3，然后删除<hanla></hanla>F1。此时<hanla></hanla>F2<hanla></hanla>和<hanla></hanla>F3<hanla></hanla>的连接计数值分别是（）。</li>
</ol>
<p>A、0、1 <strong>B、1、1</strong></p>
<p>C、1、2 D、2、1</p>
<p><strong>解析</strong>：</p>
<ol type="1">
<li>初始状态：
<ul>
<li>F1<hanla></hanla>的连接计数为<hanla></hanla>1（仅自身指向<hanla></hanla>inode）。</li>
</ul></li>
<li>建立符号链接<hanla></hanla>F2：
<ul>
<li>符号链接（软链接）是独立文件，<strong>不增加<hanla></hanla>F1<hanla></hanla>的连接计数</strong>。</li>
<li>F1<hanla></hanla>的连接计数仍为<hanla></hanla>1，F2<hanla></hanla>的连接计数为<hanla></hanla>1（指向自身）。</li>
</ul></li>
<li>建立硬链接<hanla></hanla>F3：
<ul>
<li>硬链接与<hanla></hanla>F1<hanla></hanla>共享<hanla></hanla>inode，<strong>F1<hanla></hanla>和<hanla></hanla>F3<hanla></hanla>的连接计数变为<hanla></hanla>2</strong>。</li>
</ul></li>
<li>删除<hanla></hanla>F1：
<ul>
<li>删除<hanla></hanla>F1<hanla></hanla>后，其连接计数减<hanla></hanla>1（从<hanla></hanla>2→1），此时仅剩<hanla></hanla>F3<hanla></hanla>指向<hanla></hanla>inode。</li>
<li>符号链接<hanla></hanla>F2<hanla></hanla>仍存在，但指向已删除的<hanla></hanla>F1（成为悬空链接），其连接计数仍为<hanla></hanla>1（自身计数）。</li>
</ul></li>
</ol>
<p><strong>关键点</strong>：</p>
<ul>
<li>硬链接影响<hanla></hanla>inode<hanla></hanla>连接计数，符号链接不影响。</li>
<li>删除原文件后：
<ul>
<li>硬链接<hanla></hanla>F3<hanla></hanla>仍有效（连接计数<hanla></hanla>=1）。</li>
<li>符号链接<hanla></hanla>F2<hanla></hanla>失效但计数不变（因它是独立文件）。</li>
</ul></li>
</ul>
<p><strong>结论</strong>：F2=1（悬空），F3=1（选<hanla></hanla>B）。</p>
<ol start="7" type="1">
<li>某文件系统为一级目录结构，文件的数据一次性写入磁盘，已写入的文件不可修改，但可多次创建新文件。请回答如下问题。</li>
</ol>
<p>（1）在连续、链式、索引三种文件的数据块组织方式中，哪种更合适？要求说明理由。为定位文件数据块，需在<hanla></hanla>FCB<hanla></hanla>中设计哪些相关字段？</p>
<p>（2）为快速找到文件，对于<hanla></hanla>FCB，是集中存储好，还是与对应的文件数据块连续存储好？要求说明理由。</p>
<p>(1)<hanla></hanla>在磁盘中连续存放<hanla></hanla>(采取连续结构)，磁盘寻道时间更短，文件随机访问效率更高；在<hanla></hanla>FCB<hanla></hanla>中加入的字段为：&lt;起始块号，块数&gt;<hanla></hanla>或者<hanla></hanla>&lt;起始块号，结束块号&gt;。</p>
<p>(2)<hanla></hanla>将所有<hanla></hanla>FCB<hanla></hanla>集中存放，文件数据集中存放。这样在随机查找文件名时，只需访问<hanla></hanla>FCB<hanla></hanla>对应的块，可减少磁头移动和磁盘<hanla></hanla>I/O<hanla></hanla>访问的次数。</p>
<ol start="8" type="1">
<li>若一个用户进程通过<hanla></hanla>read<hanla></hanla>系统调用读取一个磁盘文件中的数据，则下列关于此过程的叙述中，正确的是</li>
</ol>
<p>Ⅰ.<hanla></hanla>若该文件的数据不在内存，则该进程进入睡眠等待状态</p>
<p>Ⅱ.<hanla></hanla>请求<hanla></hanla>read<hanla></hanla>系统调用会导致<hanla></hanla>CPU<hanla></hanla>从用户态切换到核心态</p>
<p>Ⅲ.read<hanla></hanla>系统调用的参数应包括文件的名称</p>
<p><strong>A.<hanla></hanla>仅Ⅰ，Ⅱ</strong> B.<hanla></hanla>仅Ⅰ，Ⅲ</p>
<p>C. 仅Ⅱ，Ⅲ D.Ⅰ，Ⅱ，Ⅲ</p>
<h1 id="第9章-设备管理">第<hanla></hanla>9<hanla></hanla>章 设备管理</h1>
<h2 id="练习题-8">练习题</h2>
<p>一个磁盘驱动器有<hanla></hanla>5000<hanla></hanla>个柱面（编号<hanla></hanla>0<hanla></hanla>到<hanla></hanla>4999）。当前磁头位于柱面<hanla></hanla>2150，上一次请求的柱面是<hanla></hanla>1805。待处理的请求队列（按<hanla></hanla>FIFO<hanla></hanla>顺序）为：</p>
<figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2069</span>, <span class="hljs-number">1212</span>, <span class="hljs-number">2296</span>, <span class="hljs-number">2800</span>, <span class="hljs-number">544</span>, <span class="hljs-number">1618</span>, <span class="hljs-number">356</span>, <span class="hljs-number">1523</span>, <span class="hljs-number">4965</span>, <span class="hljs-number">3681</span><br></code></pre></td></tr></tbody></table></figure>
<p>需要计算以下磁盘调度算法下磁头移动的总距离（柱面数）：</p>
<ol type="1">
<li><strong>FCFS</strong>（先来先服务）</li>
<li><strong>SCAN</strong>（电梯算法）</li>
<li><strong>C-SCAN</strong>（循环扫描）</li>
</ol>
<p><strong>1. FCFS（先来先服务）</strong></p>
<ul>
<li><p><strong>规则</strong>：按请求到达的顺序依次处理。</p></li>
<li><p>移动顺序：从当前磁头位置<hanla></hanla>2150<hanla></hanla>开始，依次访问队列中的请求：</p>
<figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2150</span> → <span class="hljs-number">2069</span> → <span class="hljs-number">1212</span> → <span class="hljs-number">2296</span> → <span class="hljs-number">2800</span> → <span class="hljs-number">544</span> → <span class="hljs-number">1618</span> → <span class="hljs-number">356</span> → <span class="hljs-number">1523</span> → <span class="hljs-number">4965</span> → <span class="hljs-number">3681</span><br></code></pre></td></tr></tbody></table></figure></li>
<li><p>计算距离：</p>
<ul>
<li>|2150 - 2069| = 81</li>
<li>|2069 - 1212| = 857</li>
<li>|1212 - 2296| = 1084</li>
<li>|2296 - 2800| = 504</li>
<li>|2800 - 544| = 2256</li>
<li>|544 - 1618| = 1074</li>
<li>|1618 - 356| = 1262</li>
<li>|356 - 1523| = 1167</li>
<li>|1523 - 4965| = 3442</li>
<li>|4965 - 3681| = 1284</li>
</ul></li>
<li><p><strong>总距离</strong>：81 + 857 + 1084 + 504 + 2256 + 1074 + 1262 + 1167 + 3442 + 1284 = <strong>13011</strong></p></li>
</ul>
<p><strong>2. SCAN（电梯算法）</strong></p>
<ul>
<li><p><strong>规则</strong>：磁头沿一个方向移动，直到到达磁盘一端，然后反向移动。</p></li>
<li><p><strong>初始方向</strong>：上一次请求是<hanla></hanla>1805，当前是<hanla></hanla>2150，说明磁头正在<strong>向外移动</strong>（从<hanla></hanla>1805→2150，方向：增大）。</p></li>
<li><p>移动顺序：</p>
<ol type="1">
<li><p>向外移动（增大方向）处理所有≥2150<hanla></hanla>的请求：</p>
<figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2150 </span>→ <span class="hljs-number">2296</span> → <span class="hljs-number">2800</span> → <span class="hljs-number">3681</span> → <span class="hljs-number">4965</span>（到达磁盘末端）<br></code></pre></td></tr></tbody></table></figure></li>
<li><p>反向移动（减小方向）处理所有剩余请求：</p>
<figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4965 </span>→ <span class="hljs-number">3681</span> → <span class="hljs-number">2069</span> → <span class="hljs-number">1618</span> → <span class="hljs-number">1523</span> → <span class="hljs-number">1212</span> → <span class="hljs-number">544</span> → <span class="hljs-number">356</span><br></code></pre></td></tr></tbody></table></figure></li>
</ol>
<ul>
<li><strong>注意</strong>：3681<hanla></hanla>在向外移动时已处理，反向时不再重复计算。</li>
</ul></li>
<li><p>计算距离：</p>
<ul>
<li>向外移动：
<ul>
<li>|2150 - 2296| = 146</li>
<li>|2296 - 2800| = 504</li>
<li>|2800 - 3681| = 881</li>
<li>|3681 - 4965| = 1284</li>
</ul></li>
<li>反向移动：
<ul>
<li>|4965 - 2069| = 2896</li>
<li>|2069 - 1618| = 451</li>
<li>|1618 - 1523| = 95</li>
<li>|1523 - 1212| = 311</li>
<li>|1212 - 544| = 668</li>
<li>|544 - 356| = 188</li>
</ul></li>
</ul></li>
<li><p><strong>总距离</strong>：146 + 504 + 881 + 1284 + 2896 + 451 + 95 + 311 + 668 + 188 = <strong>7424</strong></p></li>
</ul>
<p><strong>3. C-SCAN（循环扫描）</strong></p>
<ul>
<li><p><strong>规则</strong>：磁头沿一个方向移动到底后，立即返回磁盘起点，继续同一方向移动。</p></li>
<li><p><strong>初始方向</strong>：向外移动（增大方向）。</p></li>
<li><p>移动顺序：</p>
<ol type="1">
<li><p>向外移动处理所有≥2150<hanla></hanla>的请求：</p>
<figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2150 </span>→ <span class="hljs-number">2296</span> → <span class="hljs-number">2800</span> → <span class="hljs-number">3681</span> → <span class="hljs-number">4965</span>（到达末端）<br></code></pre></td></tr></tbody></table></figure></li>
<li><p>立即返回到<hanla></hanla>0（不处理请求）：</p>
<figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4965 </span>→ <span class="hljs-number">0</span><br></code></pre></td></tr></tbody></table></figure></li>
<li><p>重新向外移动处理剩余请求：</p>
<figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>→ <span class="hljs-number">356</span> → <span class="hljs-number">544</span> → <span class="hljs-number">1212</span> → <span class="hljs-number">1523</span> → <span class="hljs-number">1618</span> → <span class="hljs-number">2069</span><br></code></pre></td></tr></tbody></table></figure></li>
</ol></li>
<li><p>计算距离：</p>
<ul>
<li>向外移动：
<ul>
<li>|2150 - 2296| = 146</li>
<li>|2296 - 2800| = 504</li>
<li>|2800 - 3681| = 881</li>
<li>|3681 - 4965| = 1284</li>
</ul></li>
<li>返回：
<ul>
<li>|4965 - 0| = 4965</li>
</ul></li>
<li>重新向外移动：
<ul>
<li>|0 - 356| = 356</li>
<li>|356 - 544| = 188</li>
<li>|544 - 1212| = 668</li>
<li>|1212 - 1523| = 311</li>
<li>|1523 - 1618| = 95</li>
<li>|1618 - 2069| = 451</li>
</ul></li>
</ul></li>
<li><p><strong>总距离</strong>：146 + 504 + 881 + 1284 + 4965 + 356 + 188 + 668 + 311 + 95 + 451 = <strong>9849</strong></p></li>
</ul>
<hr>
<p><strong>最终答案</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">调度算法</th>
<th style="text-align: center;">总移动距离（柱面数）</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">FCFS</td>
<td style="text-align: center;">13011</td>
</tr>
<tr class="even">
<td style="text-align: center;">SCAN</td>
<td style="text-align: center;">7424</td>
</tr>
<tr class="odd">
<td style="text-align: center;">C-SCAN</td>
<td style="text-align: center;">9849</td>
</tr>
</tbody>
</table>
<p>DMA<hanla></hanla>如何提高系统并发性？DMA<hanla></hanla>如何使硬件设计复杂化？</p>
<ol type="1">
<li></li>
</ol>
<ol type="1">
<li>减轻<hanla></hanla>CPU<hanla></hanla>负担：
<ul>
<li><strong>传统<hanla></hanla>I/O</strong>：CPU<hanla></hanla>需要亲自处理数据搬运（如从磁盘到内存），导致频繁中断和上下文切换。</li>
<li><strong>DMA（直接内存访问）</strong>：由<hanla></hanla>DMA<hanla></hanla>控制器（DMAC）直接管理<hanla></hanla>I/O<hanla></hanla>设备与内存的数据传输，<strong>CPU<hanla></hanla>仅在传输开始和结束时介入</strong>，期间可执行其他任务。</li>
</ul></li>
<li>并行操作：
<ul>
<li>CPU<hanla></hanla>计算与<hanla></hanla>I/O<hanla></hanla>传输可<strong>同时进行</strong>（如<hanla></hanla>CPU<hanla></hanla>处理已加载的数据，同时<hanla></hanla>DMA<hanla></hanla>加载下一批数据）。</li>
</ul></li>
<li>减少总线竞争：
<ul>
<li>DMA<hanla></hanla>通过<strong>独占总线周期</strong>批量传输数据，比<hanla></hanla>CPU<hanla></hanla>逐字节操作更高效。</li>
</ul></li>
</ol>
<ol start="2" type="1">
<li></li>
</ol>
<ol type="1">
<li>硬件复杂性：
<ul>
<li>需额外设计<hanla></hanla><strong>DMA<hanla></hanla>控制器</strong>，并集成到主板或设备中（如磁盘控制器）。</li>
</ul></li>
<li>总线仲裁：
<ul>
<li>DMA<hanla></hanla>与<hanla></hanla>CPU<hanla></hanla>可能竞争总线，需引入<strong>总线仲裁逻辑</strong>（如优先级机制）。</li>
</ul></li>
<li>缓存一致性：
<ul>
<li>DMA<hanla></hanla>直接操作内存时，可能绕过<hanla></hanla>CPU<hanla></hanla>缓存，需硬件机制（如缓存嗅探）保证数据一致性。</li>
</ul></li>
<li>地址映射：
<ul>
<li>DMA<hanla></hanla>需知晓物理地址，可能需<hanla></hanla><strong>MMU（内存管理单元）</strong>配合，避免访问非法内存区域。</li>
</ul></li>
</ol>
<p>为什么需要同步提升总线和设备速度？</p>
<ol type="1">
<li>避免性能瓶颈：
<ul>
<li><strong>CPU<hanla></hanla>速度↑</strong> → 处理能力↑，但若总线或设备速度不变，<strong>I/O<hanla></hanla>成为瓶颈</strong>（如<hanla></hanla>CPU<hanla></hanla>等待慢速磁盘数据）。</li>
<li>例：1GHz CPU + 100MB/s<hanla></hanla>磁盘 → 磁盘拖累整体性能。</li>
</ul></li>
<li>平衡系统吞吐量：
<ul>
<li>高速<hanla></hanla>CPU<hanla></hanla>需匹配高速总线（如<hanla></hanla>PCIe 5.0）和存储设备（如<hanla></hanla>NVMe SSD），否则<strong>资源利用率低下</strong>。</li>
</ul></li>
<li>减少等待时间：
<ul>
<li>现代<hanla></hanla>CPU<hanla></hanla>采用多级流水线和超标量架构，<strong>停滞（stall）会大幅降低效率</strong>。快速<hanla></hanla>I/O<hanla></hanla>设备可减少等待。</li>
</ul></li>
<li>支持高并发：
<ul>
<li>多核<hanla></hanla>CPU<hanla></hanla>需总线带宽足够分配（如<hanla></hanla>16<hanla></hanla>核<hanla></hanla>CPU + 低带宽总线 → 核心争抢带宽）。</li>
</ul></li>
</ol>
<h2 id="选择题-7">选择题</h2>
<ol type="1">
<li>缓冲技术中的缓冲池在 _____ 中。</li>
</ol>
<p><strong>A. 主存</strong> B. 外存</p>
<p>C. ROM D. 寄存器</p>
<ol start="2" type="1">
<li>CPU<hanla></hanla>输出数据的速度远远高于打印机的打印速度，为了解决这一矛盾，可采用<hanla></hanla>_____ 。</li>
</ol>
<p>A. 并行技术 B. 通道技术</p>
<p><strong>C. 缓冲技术</strong> D. 虚存技术</p>
<ol start="3" type="1">
<li>通过硬件和软件的功能扩充，把原来独占的设备改造成能为若干用户共享的设备，这种设备称为 _____ 。</li>
</ol>
<p>A. 存储设备 B. 系统设备</p>
<p>C. 用户设备 <strong>D. 虚拟设备</strong></p>
<ol start="4" type="1">
<li>为了使多个进程能有效地同时处理输入<hanla></hanla>/<hanla></hanla>输出，最好使用 _____ 结构的缓冲技术。</li>
</ol>
<p>A. 循环缓冲 <strong>B. 缓冲池</strong></p>
<p>C. 单缓冲 D. 双缓冲</p>
<ol start="5" type="1">
<li>如果<hanla></hanla>I/O<hanla></hanla>设备与存储设备进行数据交换不经过<hanla></hanla>CPU<hanla></hanla>来完成，这种数据交换方式是 _____ 。</li>
</ol>
<p>A. 程序查询 B. 中断方式</p>
<p><strong>C. DMA<hanla></hanla>方式</strong> D. 无条件存取方式</p>
<ol start="6" type="1">
<li>在采用<hanla></hanla>Spooling 技术的系统中．用户的打印结果首先被送到 _____ 。</li>
</ol>
<p><strong>A. 磁盘固定区域</strong> B. 内存固定区域</p>
<p>C. 终端 D. 打印机</p>
<ol start="7" type="1">
<li>设备管理程序对设备的管理是借助一些数据结构来进行的，下面的 _____ 不属于设备管理数据结构。</li>
</ol>
<p>A. DCT B. COCT</p>
<p>C. CHCT <strong>D. JCB</strong></p>
<ol start="8" type="1">
<li>操作系统中的<hanla></hanla>Spooling<hanla></hanla>技术，实质是将 _____ 转化为共享设备的技术。</li>
</ol>
<p>A. 虚拟设备 <strong>B. 独占设备</strong></p>
<p>C. 脱机设备 D. 块设备</p>
<ol start="9" type="1">
<li>按 _____ 分类可将设备分为块设备和字符设备。</li>
</ol>
<p>A. 从属关系 B. 操作特性</p>
<p>C. 共享属性 <strong>D. 信息交换单位</strong></p>
<ol start="10" type="1">
<li>_____ 算法是设备分配常用的一种算法。</li>
</ol>
<p>A. 短作业优先 B. 最佳适应</p>
<p><strong>C. 先来先服务</strong> D. 首次适应</p>
<ol start="11" type="1">
<li>在下面关于设备属性的论述中，正确的论述是<hanla></hanla>_____。　</li>
</ol>
<p>A．字符设备的一个基本特征是可寻址的。</p>
<p>B．共享设备必须是可寻址的和可随机访问的设备。</p>
<p>C．共享设备是指在同一时刻，允许多个进程同时访问的设备。</p>
<p><strong>D．在分配共享设备和独占设备时，都可能引起进程死锁。</strong></p>
<ol start="12" type="1">
<li>通道是一种特殊的<hanla></hanla>___，具有执行<hanla></hanla>I/O<hanla></hanla>指令集的能力。</li>
</ol>
<p>A．I/O<hanla></hanla>设备　 　B．设备控制器</p>
<p><strong>C．处理机</strong>　　 D．I/O<hanla></hanla>控制器</p>
<ol start="13" type="1">
<li>共享设备磁盘的物理地址为（柱面号，磁头号，扇区号），磁头从当前位置移动到需访问柱面所用的时间称为 ① ，磁头从访问的柱面移动到指定扇区所用时间称为 ② 。A，B</li>
</ol>
<p>A. 寻道时间 B. 传输时间</p>
<p>C. 旋转等待时间 D. 周转时间</p>
<ol start="14" type="1">
<li>若进程<hanla></hanla>P1<hanla></hanla>访问<hanla></hanla>199<hanla></hanla>号柱面，磁头是从<hanla></hanla>0<hanla></hanla>号柱面移到<hanla></hanla>199<hanla></hanla>柱面的，且在访问期间依次出现了<hanla></hanla>P2<hanla></hanla>申请读<hanla></hanla>299<hanla></hanla>号柱面，P3<hanla></hanla>申请写<hanla></hanla>209<hanla></hanla>号柱面，P4<hanla></hanla>申请读<hanla></hanla>199<hanla></hanla>号柱面，访问完<hanla></hanla>199<hanla></hanla>号柱面以后，如果采用：先来先服务算法，将依次访问 ① ；最短寻道时间优先算法，将依次访问 ② ；扫描算法，将依次访问 ③ 。B，D，C</li>
</ol>
<p>A. 299，199，209 B. 299，209，199</p>
<p>C. 199，209，299 D. 209，199，299</p>
<p><strong>1. 先来先服务（FCFS）</strong></p>
<ul>
<li><strong>规则</strong>：按请求到达顺序处理。</li>
<li><strong>请求顺序</strong>：P2（299）→ P3（209）→ P4（199）。</li>
<li><strong>移动顺序</strong>：199（当前）→ 299 → 209 → 199。</li>
<li><strong>对应选项</strong>：B（299, 209, 199）。</li>
</ul>
<p><strong>2. 最短寻道时间优先（SSTF）</strong></p>
<ul>
<li><strong>规则</strong>：选择离当前磁头位置最近的请求。</li>
<li>计算距离：
<ul>
<li>199 → 209（距离<hanla></hanla>10）</li>
<li>199 → 299（距离<hanla></hanla>100）</li>
<li>199 → 199（距离<hanla></hanla>0，P4<hanla></hanla>请求）</li>
</ul></li>
<li>优先处理<hanla></hanla>P4（199），但题目要求<hanla></hanla>“访问完<hanla></hanla>199<hanla></hanla>号柱面以后”，因此跳过<hanla></hanla>P4，选择最近的<hanla></hanla>209：
<ul>
<li>199 → 209 → 199（P4）→ 299。</li>
</ul></li>
<li><strong>注意</strong>：若<hanla></hanla>P4<hanla></hanla>在访问<hanla></hanla>199<hanla></hanla>后立即处理，顺序为<hanla></hanla>199 → 199 → 209 → 299，但选项无此组合。最接近的是<hanla></hanla>D（209, 199, 299）。</li>
</ul>
<p><strong>3. 扫描算法（SCAN，电梯算法）</strong></p>
<ul>
<li><strong>规则</strong>：磁头单向移动到底后反向。</li>
<li><strong>初始方向</strong>：从<hanla></hanla>0→199，说明向外移动（增大方向）。</li>
<li>处理顺序：
<ol type="1">
<li>向外：199 → 209 → 299（末端）。</li>
<li>反向：299 → 209 → 199（但已处理过<hanla></hanla>209<hanla></hanla>和<hanla></hanla>199）。</li>
</ol></li>
<li><strong>实际顺序</strong>：199（当前）→ 209 → 299。</li>
<li><strong>对应选项</strong>：C（199, 209, 299）。</li>
</ul>
<p><strong>关键点</strong>：</p>
<ul>
<li>FCFS<hanla></hanla>严格按请求顺序，效率最低。</li>
<li>SSTF<hanla></hanla>优先最近请求，但可能导致饥饿。</li>
<li>SCAN<hanla></hanla>单向移动，公平性较好。</li>
</ul>
<ol start="15" type="1">
<li>存放在磁盘上的文件 _____ 。</li>
</ol>
<p>A. 只能随机访问 B. 只能顺序访问</p>
<p><strong>C. 既可随机访问，又可顺序访问</strong></p>
<p>D. 不能随机访问</p>
<ol start="16" type="1">
<li>用磁带作文件存储介质时，文件只能组织成 _____ 。</li>
</ol>
<p>A. 目录文件 B. 链接文件</p>
<p>C. 索引文件 <strong>D. 顺序文件</strong></p>
<h2 id="填空题-4">填空题</h2>
<ol type="1">
<li><p>进行设备分配时所需的数据表格主要有<strong>设备控制表（DCT，Device Control Table）</strong>、 <strong>控制器控制表（COCT，Controller Control Table）</strong> 、<strong>通道控制表（CHCT，Channel Control Table）</strong>和 <strong>系统设备表（SDT，System Device Table）</strong> 。</p></li>
<li><p>引起中断发生的事件称为<strong>中断源（Interrupt Source）</strong>。</p></li>
<li><p>常用的<hanla></hanla>I/O<hanla></hanla>控制方式有程序直接控制方式、中断控制方式、<strong>DMA<hanla></hanla>方式（Direct Memory Access）</strong>和<strong>通道控制方式（Channel Control）</strong>。</p></li>
<li><p>通道是一个独立于 <strong>CPU</strong><hanla></hanla>的专管 <strong>I/O<hanla></hanla>操作的处理器</strong>，它控制<hanla></hanla><strong>I/O<hanla></hanla>设备</strong>与内存之间的信息交换。</p></li>
<li><p>SPOOLing<hanla></hanla>系统是由磁盘中的 <strong>输入井（Input Spooling）</strong>和 <strong>输出井（Output Spooling）</strong> ，内存中的 <strong>输入缓冲区（Input Buffer）</strong> 和 <strong>输出缓冲区（Output Buffer）</strong>，以及<strong>输入进程（Input Process）</strong>和<strong>输出进程（Output Process）</strong>所构成。</p></li>
<li><p>设备分配程序分配外部设备时，先分配 <strong>设备（Device）</strong>，再分配 <strong>控制器（Controller）</strong>，最后分配 <strong>通道（Channel）</strong>。</p></li>
<li><p>中断方式适合于<strong>低速设备（如键盘、鼠标）</strong>，DMA<hanla></hanla>方式适合于 <strong>高速设备（如磁盘、网卡）</strong> 。</p></li>
<li><p>缓冲区的组织方式可分为 <strong>单缓冲（Single Buffer）</strong>、<strong>双缓冲（Double Buffer）</strong>、<strong>循环缓冲（Circular Buffer）</strong>和缓冲池。</p></li>
<li><p>缓冲池中有三种类型的缓冲队列：<strong>空闲缓冲区队列（Empty Buffer Queue）</strong>、<strong>输入缓冲区队列（Input Buffer Queue）</strong>、<strong>输出缓冲区队列（Output Buffer Queue）</strong>。</p></li>
<li><p>大多数设备控制器由三部分构成：<strong>设备接口（Device Interface）</strong>、<strong>控制器逻辑（Controller Logic）</strong>、 <strong>系统接口（System Interface）</strong>。</p></li>
<li><p>活动头磁盘的访问时间包括<strong>寻道时间（Seek Time）</strong> 、<strong>旋转延迟时间（Rotational Latency）</strong>和 <strong>传输时间（Transfer Time）</strong>。</p></li>
<li><p><strong>最短寻道时间优先（SSTF，Shortest Seek Time First）</strong>算法选择与当前磁头所在磁道距离最近的请求作为下一次服务的对象。</p></li>
</ol>
<h2 id="考研题-2">考研题</h2>
<ol type="1">
<li>程序员利用系统调用打开<hanla></hanla>I/O<hanla></hanla>设备时，通常使用的设备标识是（）。</li>
</ol>
<p><strong>A、逻辑设备名</strong> B、物理设备名</p>
<p>C、主设备号 D、从设备号</p>
<ol start="2" type="1">
<li>下列选项中，能引起外部中断的事件是（）。</li>
</ol>
<p><strong>A、键盘输入</strong> B、除数为<hanla></hanla>0</p>
<p>C、浮点运算下溢 D、访存缺页</p>
<ol start="3" type="1">
<li>本地用户通过键盘登陆系统时，首先获得键盘输入信息的程序是 。</li>
</ol>
<p>A.<hanla></hanla>命令解释程序 <strong>B.<hanla></hanla>中断处理程序</strong></p>
<p>C.<hanla></hanla>系统调用程序 D.<hanla></hanla>用户登陆程序</p>
<ol start="4" type="1">
<li>用户程序发出磁盘<hanla></hanla>I/O<hanla></hanla>请求后，系统的正确处理流程是<hanla></hanla>______。</li>
</ol>
<p>A、用户程序→系统调用处理程序→中断处理程序→设备驱动程序</p>
<p><strong>B、用户程序→系统调用处理程序→设备驱动程序→中断处理程序</strong></p>
<p>C、用户程序→设备驱动程序→系统调用处理程序→中断处理程序</p>
<p>D、用户程序→设备驱动程序→中断处理程序→系统调用处理程序</p>
<ol start="5" type="1">
<li>某文件占<hanla></hanla>10<hanla></hanla>个磁盘块，现要把该文件磁盘块逐个读入主存缓冲区，并送用户区进行分析。假设一个缓冲区与一个磁盘块大小相同，把一个磁盘块读入缓存的时间为<hanla></hanla>100μs，将缓冲区的数据传送到用户区的时间是<hanla></hanla>50μs，CPU<hanla></hanla>对一块数据进行分析的时间是<hanla></hanla>50μs。在单缓冲区及双缓冲区结构下，读入并分析完该文件的时间分别是<hanla></hanla>____。</li>
</ol>
<p>A、1500μs ，1000μs <strong>B、1550μs，1100μs</strong></p>
<p>C、1550μs ，1550μs D、2000μs，2000μs</p>
<ol start="6" type="1">
<li>中断处理和子程序调用都需要压栈保护现场，中断处理一定会保存而子程序调用不需要保存其内容的是（）。</li>
</ol>
<p>A．程序计数器 <strong>B.<hanla></hanla>程序状态寄存器</strong></p>
<p>C．通用数据寄存器 D.<hanla></hanla>通用地址寄存器</p>
<ol start="7" type="1">
<li>操作系统的<hanla></hanla>I/O<hanla></hanla>子系统通常由四个层次组成，每一层明确定义了与邻近层次的接口。其合理的层次组织排列顺序是<hanla></hanla>()。</li>
</ol>
<p><strong>A、用户级<hanla></hanla>I/O<hanla></hanla>软件、设备无关软件、设备驱动程序、中断处理程序</strong></p>
<p>B、用户级<hanla></hanla>I/O<hanla></hanla>软件、设备无关软件、中断处理程序、设备驱动程序</p>
<p>C、用户级<hanla></hanla>I/O<hanla></hanla>软件、设备驱动程序、设备无关软件、中断处理程序</p>
<p>D、用户级<hanla></hanla>I/O<hanla></hanla>软件、中断处理程序、设备无关软件、设备驱动程序</p>
<ol start="8" type="1">
<li>假设磁头当前位于第<hanla></hanla>105<hanla></hanla>道，正在向磁道序号增加的方向移动。现有一个磁道访问序列请求为<hanla></hanla>35、45、12、68、110、180、170、195，采用<hanla></hanla>SCAN<hanla></hanla>算法得到的磁道访问序列为（）。</li>
</ol>
<p><strong>A、110、170、180、195、68、45、35、12</strong></p>
<p>B、110、68、45、35、12、170、180、195</p>
<p>C、110、170、180、195、12、35、45、68</p>
<p>D、12、35、45、68、110、170、180、195</p>
<ol start="9" type="1">
<li><p>下列选项中，不能改善磁盘<hanla></hanla>I/O<hanla></hanla>性能的是（）</p>
<p>A．重排<hanla></hanla>I/O<hanla></hanla>请求次序</p>
<p><strong>B．在一个磁盘上设置多个分区</strong></p>
<p>C．预读和滞后写</p>
<p>D．优化文件物理块的分布</p></li>
<li><p>假设计算机系统采用<hanla></hanla>CSCAN（循环扫描）磁盘调度策略，使用<hanla></hanla>2KB<hanla></hanla>的内存空间记录<hanla></hanla>16384<hanla></hanla>个磁盘块的空闲状态。</p></li>
</ol>
<p>（1）请说明在上述条件下如何进行磁盘块空闲状态管理。</p>
<p>（2）设某单面磁盘旋转速度为每分钟<hanla></hanla>6000<hanla></hanla>转，每个磁道有<hanla></hanla>100<hanla></hanla>个扇区，相邻磁道间的平均移动时间为<hanla></hanla>1ms。若在某时刻，磁头位于<hanla></hanla>100<hanla></hanla>号磁道处，并沿着磁道号增大的方向移动（如图所示），磁道号请求队列为<hanla></hanla>50，90，30，120，对请求队列中的每个磁道需读取<hanla></hanla>1<hanla></hanla>个随机分布的扇区，则读完这个扇区点共需要多少时间？要求给出计算过程。</p>
<p>（3）如果将磁盘替换为随机访问的<hanla></hanla>Flash<hanla></hanla>半导体存储器（如<hanla></hanla>U<hanla></hanla>盘、SSD<hanla></hanla>等），是否有比<hanla></hanla>CSCAN<hanla></hanla>更高效的磁盘调度策略？若有，给出磁盘调度策略的名称并说明理由；若无，说明理由。</p>
<p><img src="https://blogwzx.oss-cn-beijing.aliyuncs.com/image-20250504204325209.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://blogwzx.oss-cn-beijing.aliyuncs.com/image-20250504204348504.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://blogwzx.oss-cn-beijing.aliyuncs.com/image-20250504204609657.png" srcset="/img/loading.gif" lazyload></p>

                
              </div>
            
            <hr>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%AD%A6%E4%B9%A0/" class="category-chain-item">学习</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%A4%8D%E4%B9%A0/" class="print-no-link">#复习</a>
      
        <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF%E4%B8%93%E4%B8%9A/" class="print-no-link">#计算机科学与技术专业</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>操作系统复习笔记<hanla></hanla></div>
      <div>https://striver98.github.io/2025/04/21/<hanla></hanla>操作系统复习笔记<hanla></hanla>/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div><hanla></hanla>作者<hanla></hanla></div>
          <div>Wang Zhixuan</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div><hanla></hanla>发布于<hanla></hanla></div>
          <div>2025<hanla></hanla>年<hanla></hanla>4<hanla></hanla>月<hanla></hanla>21<hanla></hanla>日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/04/28/%E4%B8%9C%E6%B9%96%E4%B9%8B%E8%A1%8C/" title="东湖之行">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">东湖之行</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/02/17/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9C%AC%E7%A7%91%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E8%AE%B0%E5%BD%95/" title="自动化本科毕业设计记录">
                        <span class="hidden-mobile">自动化本科毕业设计记录</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索<hanla></hanla></h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">×</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input"><hanla></hanla>关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a>
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script>
  <link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css">

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script>
<script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script>
<script src="/js/events.js"></script>
<script src="/js/plugins.js"></script>





  
    <script src="/js/img-lazyload.js"></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer="" src="/js/leancloud.js"></script>

  <script src="/js/local-search.js"></script>

  <script defer="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script src="/js/boot.js"></script>


  

  <noscript>
    <div class="noscript-warning"><hanla></hanla>博客在允许 JavaScript 运行的环境下浏览效果更佳<hanla></hanla></div>
  </noscript>


</body></html>